<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>React入门</title>
      <link href="/React%E5%85%A5%E9%97%A8/"/>
      <url>/React%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。</p><p>参考资料</p><ul><li><a href="https://react.docschina.org/tutorial/tutorial.html#overview" target="_blank" rel="noopener">React官方教程</a></li><li><a href="http://huziketang.mangojuice.top/books/react/lesson12" target="_blank" rel="noopener">React.js小书</a></li></ul><ol><li><p>什么是JSX<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1g50bdcj2gwj20hm075aaq.jpg" alt="jsx"></p></li><li><p><a href="http://huziketang.mangojuice.top/books/react/lesson7" target="_blank" rel="noopener">render方法</a></p></li></ol><ul><li>React.js中一切皆组件。一个组件类必须要实现一个 render 方法，这个 render 方法必须要返回一个 JSX 元素。但这里要注意的是，必须要用一个外层的 JSX 元素把所有内容包裹起来。返回并列多个 JSX 元素是不合法的</li><li>在 JSX 当中你可以插入 JavaScript 的表达式，表达式返回的结果会相应地渲染到页面上。表达式用 {} 包裹。<ul><li>利用JSX可以增加一些逻辑性的东西，或者组合一些内容</li></ul></li><li>自定义的组件都<strong>必须要</strong>用大写字母开头，普通的 HTML 标签都用小写字母开头。</li><li>通过在其它地方使用组件的标签，我们就可以插入一个组件，这样子在这个地方就会调用标签组件的render方法，非常利于组件的重复利用，多个不同的组件可以组成组件树(构建一个页面的逻辑)</li><li>为 React 的组件添加事件监听是很简单的事情，你只需要使用 React.js 提供了一系列的 on<em> 方法即可。React.js 会给每个事件监听传入一个 <strong>event 对象</strong>，这个对象提供的功能和浏览器提供的功能一致，而且它是兼容所有浏览器的。React.js 的事件监听方法需要<strong>手动 bind 到当前实例</strong>，这种模式在 React.js 中非常常用。这些 on</em> 的事件监听只能用在普通的 HTML 的标签上，而<strong>不能用在组件标签上</strong>。</li><li>bind的作用：如果你想在事件函数当中使用当前的实例，你需要手动地将实例方法 bind 到当前实例上再传入给 React.js。</li></ul><ol start="3"><li><a href="http://huziketang.mangojuice.top/books/react/lesson10" target="_blank" rel="noopener">state与props</a></li></ol><ul><li><strong>一个组件的显示形态是由这个组件的数据状态(state)和配置参数(props)决定的</strong></li><li>state<ul><li>state 的主要作用是用于组件保存、控制、修改<strong>自己的可变状态</strong>。state 在组件内部初始化，可以被组件自身修改，而<strong>外部不能访问也不能修改</strong>。你可以认为 state 是一个局部的、只能被组件自身控制的数据源。state 中状态可以通过 this.setState 方法进行更新，setState 会导致组件的重新渲染。</li><li>setstate:setState 方法由父类 Component 所提供。当我们调用这个函数的时候，React.js 会更新组件的状态 state ，并且<strong>重新调用 render 方法</strong>，然后再把 render 方法所渲染的最新的内容显示到页面上。它接受一个对象或者函数作为参数。</li><li>当你调用 setState 的时候，React.js 并不会马上修改 state。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新。</li><li>并不是每一次调用setState方法都会重新调用render方法，而是将对同一state的修改集合到一起再去同一渲染</li><li><a href="https://imweb.io/topic/5b189d04d4c96b9b1b4c4ed6" target="_blank" rel="noopener">React中的setState方法</a>:setState是异步执行的，所以需要一些方法来控制</li><li>props<ul><li>props 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props，否则组件的 props 永远保持不变</li><li>每个组件都可以接受一个 props 参数，它是一个对象，包含了所有你对这个组件的配置。</li><li>在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为 props 对象的键值</li><li>React.js 也提供了一种方式 defaultProps，可以方便的做到默认配置。</li><li><strong>props 一旦传入进来就不能改变。</strong></li><li>组件的使用者可以主动地通过重新渲染的方式把新的 props 传入组件当中，这样这个组件中由 props 决定的显示形态也会得到相应的改变。</li></ul></li></ul></li></ul><ol start="4"><li><a href="https://www.runoob.com/react/react-component-life-cycle.html" target="_blank" rel="noopener">React组件生命周期</a> </li></ol><ul><li>React<ul><li>JavaScript<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a></li><li>bind，如果你想在事件函数当中使用当前的实例，你需要手动地将实例方法 bind 到当前实例上再传入给 React.js。 相当于通过bind(this)来完成一个绑定当前实例的工作，方便在方法内调用实例的方法以及state状态或者props</li><li>挂载阶段的组件生命周期<ul><li>挂载的概念：React.js 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载</li><li>构建组件的生命周期<ul><li>-&gt; constructor()</li><li>-&gt; componentWillMount()</li><li>-&gt; render()</li><li>-&gt; componentDidMount()</li></ul></li><li>生命周期中的作用<ul><li>我们一般会把组件的 state 的初始化工作放在 constructor 里面去做；</li><li>componentWillMount：在 componentWillMount 进行组件的启动工作，例如 Ajax 数据拉取、定时器的启动；</li><li>componentWillUnmount：组件从页面上销毁的时候，有时候需要一些数据的清理，例如定时器的清理，就会放在 componentWillUnmount 里面去做。</li><li>componentDidMount： 一般来说，有些组件的启动工作是依赖 DOM 的，例如动画的启动，而 componentWillMount 的时候组件还没挂载完成，所以没法进行这些启动工作，这时候就可以把这些操作放在 componentDidMount 当中。</li></ul></li></ul></li><li>更新阶段的组件生命周期<ul><li>componentWillReceiveProps</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ul></li></ul></li></ul><ol start="5"><li><a href="https://imweb.io/topic/5985cc4d35d7d0a321c5eb75" target="_blank" rel="noopener">React渲染机制解析</a></li></ol><ul><li>渲染过程：在页面一开始打开的时候，React会调用render函数构建一棵Dom树，在state/props发生改变的时候，render函数会被再次调用渲染出另外一棵树，接着，React会用对两棵树进行对比，找到需要更新的地方批量改动。</li><li>Diff算法：Diff算法只会对同层的节点进行比较。<a href="https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/learn-dom-tree.html" target="_blank" rel="noopener">DOM结构介绍</a><ul><li>假设1：两个相同的组件产生类似的DOM结构，不同组件产生不同DOM结构</li><li>假设2：对于同一层次的一组子节点，它们可以通过唯一的id区分</li></ul></li><li>比较节点类型<ul><li>节点类型相同<ul><li>DOM元素类型：只改变需要改变的属性</li><li>React组件类型：触发更新过程<ul><li>shouldComponentUpdate</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ul></li></ul></li><li>节点类型不同：直接删除旧节点，创建新节点</li></ul></li></ul><h3 id="点赞按钮的例子"><a href="#点赞按钮的例子" class="headerlink" title="点赞按钮的例子"></a><a href="https://codesandbox.io/s/dianzananniu-f9dhn" target="_blank" rel="noopener">点赞按钮的例子</a></h3><h4 id="利用state存储状态例子"><a href="#利用state存储状态例子" class="headerlink" title="利用state存储状态例子"></a>利用state存储状态例子</h4><pre><code class="javaScript">// 利用state存储状态class LikeButton extends Component {  constructor () {    super()    this.state = { isLiked: false }  }  handleClickOnLikeButton () {    this.setState({      isLiked: !this.state.isLiked    })  }  render () {    return (      &lt;button onClick={this.handleClickOnLikeButton.bind(this)}&gt;        {this.state.isLiked ? &#39;取消&#39; : &#39;点赞&#39;} 👍      &lt;/button&gt;    )  }}</code></pre><h4 id="维持组件可重复利用"><a href="#维持组件可重复利用" class="headerlink" title="维持组件可重复利用"></a>维持组件可重复利用</h4><pre><code class="javaScript">class LikeButton extends Component {  constructor () {    super()    this.state = { isLiked: false }  }  handleClickOnLikeButton () {    this.setState({      isLiked: !this.state.isLiked    })  }  render () {    // 设置了渲染的内容，方便后期更改    const likedText = this.props.likedText || &#39;取消&#39;    const unlikedText = this.props.unlikedText || &#39;点赞&#39;    return (      &lt;button onClick={this.handleClickOnLikeButton.bind(this)}&gt;        {this.state.isLiked ? likedText : unlikedText} 👍      &lt;/button&gt;    )  }}</code></pre><h4 id="利用props来重用组件"><a href="#利用props来重用组件" class="headerlink" title="利用props来重用组件"></a>利用props来重用组件</h4><pre><code class="javascript">class Index extends Component {  render () {    return (      &lt;div&gt;        &lt;LikeButton likedText=&#39;已赞&#39; unlikedText=&#39;赞&#39; /&gt;      &lt;/div&gt;    )  }}</code></pre><h4 id="如何设置默认值"><a href="#如何设置默认值" class="headerlink" title="如何设置默认值"></a>如何设置默认值</h4><pre><code class="javascript">class LikeButton extends Component {  // 在这里设置默认值  static defaultProps = {    likedText: &#39;取消&#39;,    unlikedText: &#39;点赞&#39;  }  constructor () {    super()    this.state = { isLiked: false }  }  handleClickOnLikeButton () {    this.setState({      isLiked: !this.state.isLiked    })  }  render () {    return (      &lt;button onClick={this.handleClickOnLikeButton.bind(this)}&gt;      // 设置过默认值这里就不用再进行判断了        {this.state.isLiked          ? this.props.likedText          : this.props.unlikedText} 👍      &lt;/button&gt;    )  }}</code></pre>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OKR工作法</title>
      <link href="/OKR%E5%B7%A5%E4%BD%9C%E6%B3%95/"/>
      <url>/OKR%E5%B7%A5%E4%BD%9C%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="什么是OKR工作法"><a href="#什么是OKR工作法" class="headerlink" title="什么是OKR工作法"></a>什么是OKR工作法</h2><p>OKR(Objective and Key Results，目标与战略结果), 战略目标任务体系。<br>O(目标)：有挑战，可衡量的目标<br>KR(关键结果):为了达成目标的关键行动</p><p>目标管理法基于两个原则</p><ol><li><code>不要告诉下属具体怎么做，只告诉他们你想要什么，他们就会给你满意的结果</code></li><li><code>用关键结果衡量工作绩效</code></li></ol><h2 id="如何应用OKR工作法"><a href="#如何应用OKR工作法" class="headerlink" title="如何应用OKR工作法"></a>如何应用OKR工作法</h2><ul><li>设定一个关键目标<ul><li>通常是企业的使命：我们通过(什么样的价值主张)，在(什么领域或行业)(改善人们的生活或减少人们的痛苦)</li></ul></li><li>针对目标，设置三个关键成果来衡量这个目标<ul><li>每个KR都要设置<em>信心指数</em>，默认是50%，每周开会更新信心指数</li></ul></li><li>状态指标：影响目标达成的因素，完成OKR的保障</li><li>本周关注的任务：列出三件最重要的事情</li><li>未来四周的计划:哪些需要做好准备或支持的</li></ul><p>最终输出一个OKR象限图：<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1g57vq98gu6j20du0a774m.jpg" alt="OKR象限图"></p><h2 id="无法达到目标的五个关键因素"><a href="#无法达到目标的五个关键因素" class="headerlink" title="无法达到目标的五个关键因素"></a>无法达到目标的五个关键因素</h2><ol><li>没有给目标设置优先级</li></ol><ul><li>设定单一的目标，用三个关键结果来衡量它，一次只完成一个目标</li></ul><ol start="2"><li>缺乏充分沟通，导致没能准确理解目标</li></ol><ul><li>周一会议确定每个人的职责，周五会议重复本阶段的目标</li></ul><ol start="3"><li>没有做好计划</li></ol><ul><li>需要一个目标管理系统记录重要的事情</li></ul><ol start="4"><li>没有把时间花在重要的事情上</li></ol><ul><li>应用重要紧急矩阵</li></ul><ol start="5"><li>轻易放弃</li></ol><ul><li>失败后不断尝试</li></ul>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven</title>
      <link href="/Maven/"/>
      <url>/Maven/</url>
      <content type="html"><![CDATA[<h2 id="Maven项目目录结构"><a href="#Maven项目目录结构" class="headerlink" title="Maven项目目录结构"></a>Maven项目目录结构</h2><p><img src="http://ww1.sinaimg.cn/large/7f349269ly1g17a5zc3rhj204f04owe9.jpg" alt="maven目录结构"></p><h2 id="Maven命令"><a href="#Maven命令" class="headerlink" title="Maven命令"></a>Maven命令</h2><p>mvn</p><ul><li>-v 查看maven版本</li><li>compile 编译</li><li>test 测试</li><li>package 打包</li><li>clean 删除target</li><li>install 安装jar包到本地仓库中</li></ul><p>compile首先去pom文件中的dependencies查找依赖，然后去本地仓库中查找，如果本地仓库中没有，就去中央仓库查找(groupId,artifactId,version)    </p><h2 id="自动构建目录"><a href="#自动构建目录" class="headerlink" title="自动构建目录"></a>自动构建目录</h2><p>自动创建目录的两种方式：</p><ol><li>archetype:generate 按照提示进行选择(groupId,artifactId,version,package)</li><li>archetype:generate -DgroupId=组织名，公司网址的反写+项目名 -DartifactId=项目名-模块名 -Dversion=版本号 -Dpackage=代码所存在的包名</li></ol><h2 id="Maven中的坐标和仓库"><a href="#Maven中的坐标和仓库" class="headerlink" title="Maven中的坐标和仓库"></a>Maven中的坐标和仓库</h2><p>坐标(构件)(groupId,artifactId,version)<br>仓库</p><ul><li>本地仓库</li><li>中央仓库</li><li>镜像仓库(添加镜像仓库，更改本地仓库位置)</li></ul><h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><p>完整的项目构建过程包括：清理、编译、测试、打包、集成测试、验证、部署  </p><p>Maven声明周期：</p><ul><li>clean 清理项目</li><li>default 构建项目</li><li>site 生成项目站点</li></ul><p>clean、compile、test、package、install  </p><p>clean清理项目</p><ul><li>pre-clean 执行清理前的工作</li><li>clean 清理上一次构建生成的所有文件</li><li>post-clean 执行清理后的文件</li></ul><p>default 构建项目(最核心)  </p><ul><li>compile、test、package、install</li></ul><p>site 生成项目站点</p><ul><li>pre-site 在生成项目站点前要完成的工作</li><li>site 生成项目的站点文档</li><li>post-site 在生成项目站点后要完成的工作</li><li>site-deploy 发布生成的站点到服务器上</li></ul><h2 id="pom解析"><a href="#pom解析" class="headerlink" title="pom解析"></a>pom解析</h2><h2 id="maven依赖范围"><a href="#maven依赖范围" class="headerlink" title="maven依赖范围"></a>maven依赖范围</h2><p>pom中的scope(范围)： 测试，编译，运行</p><ul><li>compile 编译测试运行都有效</li><li>provided 在编译和测试的时候有效</li><li>runtime 在测试和运行时有效</li><li>test 只在测试时有效</li><li>system 与本机系统相关联，可移植性差</li><li>import 导入范围，只在使用dependencyManagement中，表示从其它的pom中导入dependecy的配置</li></ul><h2 id="maven依赖的传递"><a href="#maven依赖的传递" class="headerlink" title="maven依赖的传递"></a>maven依赖的传递</h2><h2 id="maven构建web项目"><a href="#maven构建web项目" class="headerlink" title="maven构建web项目"></a>maven构建web项目</h2>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树的遍历</title>
      <link href="/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<p>树的前序遍历，中序遍历，后序遍历以及层序遍历的java代码实现，每种都有递归和循环两种方法。<br>对于树结构的定义如下所示：</p><pre><code class="java">/*** 树结构的定义*/public static class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) {        val = x;    }}</code></pre><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><ol><li>访问根结点。</li><li>前序遍历左子树。</li><li>前序遍历右子树 </li></ol><p>递归方法：</p><pre><code class="java">/*** 前序遍历，递归方法*/public static void preorderRec(TreeNode root) {    if (root != null) {        System.out.print(root.val);        preorderRec(root.left);        preorderRec(root.right);    }}</code></pre><p>迭代方法：</p><pre><code class="java">/*** 前序遍历迭代方法*/public static void preorderIte(TreeNode root) {    if (root != null) {        // 用于存储遍历过的结点        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        TreeNode cur = root;        // 当前节点与栈都不为空        while (cur != null || !stack.isEmpty()) {            // 如果当前节点不为空，输出值，压入栈，移动到左子树            if (cur != null) {                // 前序遍历根节点首先输出，所以输出在最前                System.out.print(cur.val);                // 将cur入栈是为了后面遍历右子树                stack.push(cur);                cur = cur.left;            } else {                // 如果当前元素为空，回退到父节点，再遍历右子树，然后父节点就可以出栈了，因为他的左右子树都遍历完成了                cur = stack.pop();                cur = cur.right;            }        }    }}</code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><ol><li>中序遍历左子树。</li><li>访问根结点。</li><li>中序遍历右子树 </li></ol><p>递归方法：</p><pre><code class="java">/*** 中序遍历，循环*/private static void inOrderRec(TreeNode root) {    if (root == null) {        return;    }    inOrderRec(root.left);    System.out.print(root.val);    inOrderRec(root.right);}</code></pre><p>迭代方法：</p><pre><code class="java">/*** 中序遍历，循环*/private static void inOrderIte(TreeNode root) {    if (root == null) {        return;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    TreeNode cur = root;    while (cur != null || !stack.isEmpty()) {        if (cur != null) {            stack.push(cur);            // 先是左子树            cur = cur.left;        } else {            // 到达叶子节点，弹出栈，输出，在遍历右子树            cur = stack.pop();            // 跟前序遍历相反，这个是出栈输出            System.out.print(cur.val);            cur = cur.right;        }    }}</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><ol><li>后序遍历左子树。</li><li>后序遍历右子树 </li><li>访问根结点。</li></ol><p>递归方法：</p><pre><code class="java">/*** 后序遍历，递归*/private static void postOrderRec(TreeNode root) {    if (root == null) {        return;    }    postOrderRec(root.left);    postOrderRec(root.right);    System.out.print(root.val);}</code></pre><p>循环方法</p><pre><code class="java">/*** 后序遍历，迭代* 后序遍历的方法与前序遍历与中序遍历的方法不太相同*/private static void postOrderIte(TreeNode root) {    if (root == null) {        return;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    // 新增加一个栈,利用栈先进后出的原则，先放入根节点，然后放入右节点，最后放入左节点    Stack&lt;TreeNode&gt; output = new Stack&lt;&gt;();    TreeNode cur = root;    while (cur != null || !stack.isEmpty()) {        if (cur != null) {            output.push(cur);            stack.push(cur);            // 先进后出，所以先是右边            cur = cur.right;        } else {            // output不出栈，stack只是为了帮助找到左子树            cur = stack.pop();            cur = cur.left;        }    }    while (!output.isEmpty()) {        System.out.print(output.pop().val);    }}</code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>按照层的顺序来遍历</p><p>递归方法：</p><pre><code class="java">/*** 层序遍历， 递归方法* 首先层序遍历需要按照层来划分，也就是深度，* 然后围绕深度输出*/public static void levelOrderRec(TreeNode root) {    if (root == null) {        return;    }    // 分层遍历    for (int i = 1; i &lt;= depthIte(root); i++) {        levleOrder(root, i);    }}/*** 层序遍历辅助函数，每遍历一层level减1，直到level为1，输出这一层的元素值*/private static void levleOrder(TreeNode root, int level) {    if (root == null || level &lt; 1) {        return;    }    // 这里的level不是指树的层，指还剩的层数    if (level == 1) {        System.out.print(root.val);    }    // 每向下遍历一层，层数就减1，直到层数为1，遍历的就是这一层，输出节点的值    levleOrder(root.left, level - 1);    levleOrder(root.right, level - 1);}/*** 递归方法计算树深度*/private static int depthRec(TreeNode root) {    if (root == null) {        return 0;    }    int l = depthRec(root.left);    int r = depthRec(root.right);    if (l &gt; r) {        return l + 1;    } else {        return r + 1;    }}</code></pre><p>循环方法</p><pre><code class="java">/*** 层序遍历，非递归方法* 利用队列这个先进先出的数据结构* 入队的时候就是按照层的顺序入队，出队也 非常方便* LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用*/public static void levelOrderIte(TreeNode root) {    if (root == null) {        return;    }    TreeNode cur;    // LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.add(root);    // 每次都是当前节点出队，然后存入当前节点的左右子节点    while (queue.size() != 0) {        cur = queue.poll();        System.out.print(cur.val);        if (cur.left != null) {            queue.offer(cur.left);        }        if (cur.right != null) {            queue.offer(cur.right);        }    }}</code></pre>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符编码</title>
      <link href="/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>简单理解现代编码<br>编码简单的理解就是将字符编码成计算机可以理解的内容，看起来很简单，但是实际上还是比较复杂。字符的集合很复杂，因为世界上有很多语言，所以字符种类很多，光中文字符就有10万多个。有了字符集之后就要将字符集映射为对应的数字(因为计算机只能处理0和1)，数字还要映射成比特。各种不同的方案很多。  </p><h2 id="抽象字符表"><a href="#抽象字符表" class="headerlink" title="抽象字符表"></a>抽象字符表</h2><p>很简单的概念，就是字符的集合</p><h2 id="编码字符集"><a href="#编码字符集" class="headerlink" title="编码字符集"></a>编码字符集</h2><p><strong>将字符映射为整数或者坐标</strong>,unicode属于这一层。</p><ul><li>码点(code point)：编码空间的一个位置（与一个编码表中的某个字符对应的代码值）</li><li>码点值(code point value)： 一个字符所占用的码位<br>unicode字符集分为两部分(17个代码级别)，第一部分为第一个代码级别成为基本的多语言级别(U+0000-U+FFFF),其中(U+D800-U+DFFF)为保留字符,没有使用。第二部分为其余代码级别，其中包括辅助字符(U+10000-U+10FFFF)。</li></ul><h2 id="字符编码表"><a href="#字符编码表" class="headerlink" title="字符编码表"></a>字符编码表</h2><p>简单理解就是如何存储编码字符集的整数，是一个存储的规则。<br>将编码字符集的非负整数转换成有限比特长度的整型值序列。对于定长编码就是简单的自身映射，但是对于变长编码就比较复杂。UTF-8,UTF-16等编码方式属于这一层</p><ul><li>码元(code units)：有限比特长度的整型值序列（一个Unicode字符由一个或者两个码元组成）</li></ul><h3 id="UTF-8-8-bit-Unicode-Transformation-Format"><a href="#UTF-8-8-bit-Unicode-Transformation-Format" class="headerlink" title="UTF-8(8-bit Unicode Transformation Format)"></a><a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8(8-bit Unicode Transformation Format)</a></h3><p>是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。<br>对于UTF-8编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII码)；</p><ul><li>如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非ASCII字符)；</li><li>如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节；</li><li>如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节；</li><li>如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节；</li></ul><p>因此，对UTF-8编码中的任意字节，根据第一位，可判断是否为ASCII字符；根据前二位，可判断该字节是否为一个字符编码的第一个字节；根据前四位（如果前两位均为1），可确定该字节为字符编码的第一个字节，并且可判断对应的字符由几个字节表示；根据前五位（如果前四位为1），可判断编码是否有错误或数据传输过程中是否有错误。</p><p>在Java中，char类型描述了UTF-16编码中的一个代码单元。基本多语言级别每个字符使用16位来表示。辅助字符采用一对连续的代码单元进行编码。[保留字符U+D800-U+DBFF用于第一个代码单元，U+DC00-U+DFFF用于第二个代码单元]<br><strong>在Java当中，一个char代表一个代码单元，所以尽量少用char类型</strong></p><h2 id="字符编码方案"><a href="#字符编码方案" class="headerlink" title="字符编码方案"></a>字符编码方案</h2><p>将定长的整型值（即码元）映射到8位字节序列</p><h2 id="传输编码语法"><a href="#传输编码语法" class="headerlink" title="传输编码语法"></a>传输编码语法</h2><p>用于处理上一层次的字符编码方案提供的字节序列</p><p>参考：<a href="https://github.com/acmerfight/insight_python/blob/master/Unicode_and_Character_Sets.md" target="_blank" rel="noopener">字符编码</a></p>]]></content>
      
      <categories>
          
          <category> 有意思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最大子序列</title>
      <link href="/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>最大子序列，也可以理解为最大子序列和问题，做LeetCode的<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">第121题</a>的时候用到了这个内容，看了看Discuss发现解法非常简单，但是道理却不简单，正好数据结构与算法分析中也有这部分的内容，正好整理出来，也是自己理清思路。<br>具体每一个算法的思路都通过注释的形式放到了代码里，也方便理解。    </p><pre><code>问题：给定数组array，求这个数组的最大子序列。</code></pre><h2 id="最容易想到的方法-穷举法"><a href="#最容易想到的方法-穷举法" class="headerlink" title="最容易想到的方法 穷举法"></a>最容易想到的方法 穷举法</h2><p>时间复杂度O(N^3)</p><pre><code class="java">/** * @author ahscuml * @date 2018/8/14 * @time 21:35 */public class BruteForce {    public static int MaxSubArray(int[] array) {        // 子序列最大值        int max = array[0];        // 最大子序列的左右下标        int left = 0,right = 0;        for (int i = 0; i &lt; array.length; i++) {            for (int j = 0; j &lt;= i; j++) {                // 这是这次循环的值,默认为0                int cyclemax = 0;                for (int k = j; k &lt;= i; k++) {                    cyclemax += array[k];                }                // 保存最大子序列的左右下标                if (cyclemax &gt; max) {                    left = j;                    right = i;                    max = cyclemax;                }            }        }        // 输出最大子序列        for (int i = left; i &lt;=right ; i++) {            System.out.print(array[i] + &quot; &quot;);        }        System.out.println();        return max;    }}</code></pre><h2 id="穷举法的改进"><a href="#穷举法的改进" class="headerlink" title="穷举法的改进"></a>穷举法的改进</h2><p>时间复杂度O(N^2)</p><pre><code class="java">/** * @author ahscuml * @date 2018/8/14 * @time 22:16 */public class BruteForceOpt {    public static int MaxSubArray(int[] array) {        // 子序列最大值        int max = array[0];        // 最大子序列的左右下标        int left = 0, right = 0;        for (int i = 0; i &lt; array.length; i++) {            // 这是这次循环的值,默认为0            int cyclemax = 0;            for (int j = i; j &gt;= 0; j--) {                // 替换了内部的一个循环，减少了不必要的计算，降低复杂度                cyclemax += array[j];                // 保存最大子序列的左右下标                if (cyclemax &gt; max) {                    left = j;                    right = i;                    max = cyclemax;                }            }        }        // 输出最大子序列        for (int i = left; i &lt;= right; i++) {            System.out.print(array[i] + &quot; &quot;);        }        System.out.println();        return max;    }}</code></pre><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>时间复杂度O(NlogN)</p><pre><code class="java">/** * @author ahscuml * @date 2018/8/14 * @time 22:22 */public class Recursion {    private static int maxSubArrayRec(int[] array, int left, int right) {        // 递归最基本的情况，如果只有一个数字，不用递归。        if (left == right) {            if (array[left] &gt; 0) {                return array[left];            } else {                return 0;            }        }        // 递归的两种情况，左边最大和右边最大        int center = (left + right) / 2;        int maxLeftSum = maxSubArrayRec(array, left, center);        int maxRightSum = maxSubArrayRec(array, center + 1, right);        // 递归的第三种情况，中间最大，但是中间最大需要计算左边加上边界最大和右边加上边界最大        int maxLeftBorderSum = 0, leftBorderSum = 0;        for (int i = center; i &gt;= left; i--) {            leftBorderSum += array[i];            if (leftBorderSum &gt; maxLeftBorderSum) {                maxLeftBorderSum = leftBorderSum;            }        }        int maxRightBorderSum = 0, rightBorderSum = 0;        for (int i = center + 1; i &lt;= right; i++) {            rightBorderSum += array[i];            if (rightBorderSum &gt; maxRightBorderSum) {                maxRightBorderSum = rightBorderSum;            }        }        // 返回三种情况的最大值        return Math.max(maxLeftBorderSum, Math.max(maxRightSum, maxLeftBorderSum + maxRightBorderSum));    }    public static int maxSubArray(int[] array) {        return maxSubArrayRec(array, 0, array.length - 1);    }}</code></pre><h2 id="Kadane算法"><a href="#Kadane算法" class="headerlink" title="Kadane算法"></a><a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane&#39;s_algorithm" target="_blank" rel="noopener">Kadane算法</a></h2><p>时间复杂度O(N)，动态规划算法。<br>Kadane的算法以一个简单的归纳问题开始：如果我们知道在位置i结束的最大子阵列和，那么在位置 i + 1 处结束的最大子阵列总和是多少？ 答案结果相对简单：在位置 i + 1 结束的最大子阵列和包括在位置i结束的最大子阵列和作为前缀，或者它不包括。 因此，我们可以通过在数组上迭代一次来计算在所有位置i的位置i处结束的最大子阵列和。 当我们走的时候，我们只是跟踪我们所见过的最大数值。</p><pre><code class="java">/** * @author ahscuml * @date 2018/8/14 * @time 22:51 */public class Easy {    public static int maxSubArrary(int[] array) {        // maxSum是最大子序列的和，thisSum是以当前为终点的最大子序列的和        int maxSum = array[0], thisSum = 0;        // leftpre是以当前为终点的最大子序列的和的左下标，left是最大子序列和的下标，right是最大子序列和的右下标        int leftpre = 0, left = 0, right = 0;        for (int i = 0; i &lt; array.length; i++) {            thisSum += array[i];            if (thisSum &gt; maxSum) {                maxSum = thisSum;                right = i;                left = leftpre;            } else if (thisSum &lt; 0) {                thisSum = 0;                if (i != array.length - 1) {                    leftpre = i + 1;                }            }        }        // 输出最大子序列        for (int i = left; i &lt;= right; i++) {            System.out.print(array[i] + &quot; &quot;);        }        System.out.println();        return maxSum;    }}</code></pre>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>统计学习方法概论</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/"/>
      <url>/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/</url>
      <content type="html"><![CDATA[<h2 id="统计学习的方法"><a href="#统计学习的方法" class="headerlink" title="统计学习的方法"></a>统计学习的方法</h2><ul><li>监督学习</li><li>非监督学习</li><li>半监督学习</li><li>强化学习  </li></ul><p>《统计学习方法》中讨论的是监督学习</p><h3 id="实现统计学习方法的步骤"><a href="#实现统计学习方法的步骤" class="headerlink" title="实现统计学习方法的步骤"></a>实现统计学习方法的步骤</h3><ol><li>得到一个有限的训练数据集合</li><li>确定包含所有可能的模型的假设空间，即学习模型的 <strong>集合</strong>  </li><li>确定模型选择的准则，即学习的 <strong>策略</strong></li><li>实现求解最优模型的算法，即学习的 <strong>算法</strong></li><li>通过学习方法选择最优模型</li><li>利用学习的最优模型对新数据进行预测与分析</li></ol><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>输入空间、特征空间、输出空间</p><h4 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h4><p>输入变量与输出变量均为连续变量的预测问题</p><h5 id="回归问题分类"><a href="#回归问题分类" class="headerlink" title="回归问题分类"></a>回归问题分类</h5><p>输入变量个数：</p><ul><li>一元回归</li><li>多元回归  </li></ul><p>输入变量和输出变量之间的关系即模型的类型：</p><ul><li>线性回归</li><li>非线性回归</li></ul><h4 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h4><p>输出变量取有限个离散值<br>评价指标为分类准确率</p><h4 id="标注问题"><a href="#标注问题" class="headerlink" title="标注问题"></a>标注问题</h4><p>输入是一个观测序列，输出是一个标记序列或状态序列</p><h2 id="统计学习三要素"><a href="#统计学习三要素" class="headerlink" title="统计学习三要素"></a>统计学习三要素</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ol><li><p>什么是模型？<br>监督学习中，模型就是所要学习的条件概率分布或决策函数</p></li><li><p>什么是假设空间？<br>所有模型的集合</p></li></ol><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>统计学习的目标在于从假设空间中选择最优模型</p><ol><li>什么是策略，策略怎么理解？<br>按照什么样的准则学习。</li></ol><ul><li>损失函数：度量模型一次预测的好坏</li><li>风险函数：度量模型平均意义下的好坏<ul><li>期望风险：损失函数的数学期望，理论上。</li><li>经验风险：关于训练数据的平均损失，实际应用上。</li></ul></li></ul><ol start="2"><li><p>为什么不用期望风险？<br>因为期望风险无法直接求出，所以采用经验风险来替代期望风险。</p></li><li><p>采用经验风险后的策略？<br>经验风险最小化与结构风险最小化</p><ul><li>经验风险最小化：数量大的时候可以用经验风险估计期望风险，但是现实数量不大，容易产生过拟合。</li><li>结构风险最小化：在经验风险的基础上加上正则化项(模型复杂度相关)，避免<a href="#过拟合">过拟合</a>。</li></ul></li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是学习模型的具体方法，也就是用什么方法求解最优模型。  化身为最优化问题，也就是求全局最优解。</p><h2 id="模型评估与模型选择"><a href="#模型评估与模型选择" class="headerlink" title="模型评估与模型选择"></a>模型评估与模型选择</h2><h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>通过训练误差与测试误差来评估模型</p><h4 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h4><ul><li>条件： 空间含有不同复杂度的模型时</li><li><span id="过拟合">过拟合</span>：学习时选择的模型所包含的参数过多<br>一味追求提高对训练数据的预测能力，所选模型的复杂度往往会比真实模型更高<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1ftn1ptaitbj20jr0d33zv.jpg" alt="训练误差和测试误差与模型复杂度的关系"></li></ul><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>结构风险最小化策略的实现<br>正则化： 经验风险 + 正则化项<br>正则化的作用： 选择经验风险与模型复杂度同时较小的模型</p><ul><li><a href="https://zh.wikipedia.org/zh-hans/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80" target="_blank" rel="noopener">奥卡姆剃刀</a>应用在模型选择中： 在所有可能选择的模型中，能够很好地解释已知数据并且十分简单才是最好的模型。</li></ul><h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><ol><li>为什么要使用交叉验证？<br>如果数据量大，那么模型选择的简单方法就是区分训练集与测试集。但是往往数据量没有很大，所以采用交叉验证的的方法（重复利用数据）。</li></ol><h3 id="简单交叉验证"><a href="#简单交叉验证" class="headerlink" title="简单交叉验证"></a>简单交叉验证</h3><p>70%训练集，30%测试集</p><h3 id="S折交叉验证"><a href="#S折交叉验证" class="headerlink" title="S折交叉验证"></a><em>S</em>折交叉验证</h3><p>分为S个子集， S-1用于训练集，另外一个用于测试集，重复进行，选择一个最优的模型</p><h3 id="留一交叉验证"><a href="#留一交叉验证" class="headerlink" title="留一交叉验证"></a>留一交叉验证</h3><p>当S = N的时候采用的方法</p><h2 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h2><ol><li>什么是泛化能力<br>学习到的模型对未知数据的预测能力</li><li>什么是泛化误差<br>实际上就是期望风险<br>平时使用测试误差来评价泛化能力，现在通过理论计算来评价泛化能力，通常利用泛化误差的概率上界。</li></ol><h3 id="泛化误差上界"><a href="#泛化误差上界" class="headerlink" title="泛化误差上界"></a>泛化误差上界</h3><p>定理推导</p><h2 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>由数据学习联合概率分布，然后求出条件概率分布<br>典型模型有： 朴素贝叶斯法 和 隐马尔可夫模型</p><h3 id="判别方法"><a href="#判别方法" class="headerlink" title="判别方法"></a>判别方法</h3><p>有数据直接学习决策函数或者条件概率分布作为预测模型<br>典型的判别模型包括： $k$近邻法、感知机、决策树、逻辑斯帝回归模型、最大熵模型、支持向量机、提升方法和条件随机场等。</p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>感知机</title>
      <link href="/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>二分类的<strong>线性</strong>分类模型，输入为实例的特征向量，输出为实例的类别，取+1和-1二值。感知机对应于输入空间中将实例划分为正负两类的分离超平面，属于<strong>判别模型</strong>。<br>感知机的学习旨在最小化分类误差，所以引入基于误分类的误差函数，通过梯度下降法最小化误差函数求得感知机。 </p><h2 id="感知机算法学习思路："><a href="#感知机算法学习思路：" class="headerlink" title="感知机算法学习思路："></a>感知机算法学习思路：</h2><p>自己通过学习《统计学习方法》，对感知机有一些浅薄的理解，整理出了以下几个问题。通过回答以下问题可以了解感知机的具体思路。</p><ol><li>什么是感知机模型？</li><li>怎么求感知机模型(求的是什么)？</li><li>损失函数是什么(为什么要用损失函数)？</li><li>通过什么方法习得感知机模型(通过什么方法求得最小的损失函数)？</li><li>为什么一定可以习得感知机模型(算法的收敛性证明)</li><li>怎么优化这个算法(感知机的对偶形式)</li></ol><h2 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h2><p>输入空间到输出空间函数($w$ 是超平面的法向量，$b$是法向量的截距)：<br>$$ f(x) = sign(w * x + b)$$</p><h2 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h2><ul><li>定义：数据集的线性可分性:    </li></ul><p>习得感知机模型的思路：    </p><ul><li>目标：求得感知机就是求出超平面，也就是求出$w$与$x$两个变量。  </li><li>方法：为了求最合适的$w$与$x$，创造出损失函数，这样求感知机的问题就转化为损失函数最小化的问题。</li><li>问题：    <code>1. 如何确定损失函数？    2. 通过和种方法将损失函数降到最小？</code></li></ul><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>最容易想到损失函数就是误分类点的个数，但是这样的函数不是参数$w$与$b$的连续可导函数，不方便优化。<br>感知机采用的损失函数是误分类点到超平面的总距离(是参数$w$、$b$ 的可导函数)  </p><pre><code class="diff">+ 为什么是这个定义？？？</code></pre><ul><li>空间任意一点到超平面的距离：  </li><li>误分类点到超平面的距离：</li><li>误分类点到超平面的总距离：</li><li>经过简化习得损失函数：</li></ul><pre><code class="diff">+ ！！！为啥不考虑 $\frac{1}{\| w\|}$</code></pre><h3 id="损失函数最小化"><a href="#损失函数最小化" class="headerlink" title="损失函数最小化"></a>损失函数最小化</h3><p>采用 <a href="https://ahscuml.github.io/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"><code>随机梯度下降法(SGD)</code></a></p><h3 id="算法的收敛性证明"><a href="#算法的收敛性证明" class="headerlink" title="算法的收敛性证明"></a>算法的收敛性证明</h3><ul><li>定理2.1(Novikoff):<br>前提是数据集是线性可分数据集。  <ul><li>定理表明，误分类的次数$k$是有上界的，经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。  </li><li>当训练数据集线性可分时，感知机学习算法原始形式迭代是收敛的。  </li><li>感知机学习算法存在许多解，这些解既依赖于处置的选择，也依赖于迭代过程中误分类点的选择顺序。</li></ul></li></ul><hr><h2 id="感知机学习算法-摘自《统计学习方法》"><a href="#感知机学习算法-摘自《统计学习方法》" class="headerlink" title="感知机学习算法(摘自《统计学习方法》)"></a>感知机学习算法(摘自《统计学习方法》)</h2><h3 id="学习算法原始形式"><a href="#学习算法原始形式" class="headerlink" title="学习算法原始形式"></a>学习算法原始形式</h3><p><a href="https://blog.csdn.net/dcrmg/article/details/52416832" target="_blank" rel="noopener">数学知识，点积与叉积</a><br><img src="http://ww1.sinaimg.cn/large/7f349269ly1ftn31waqzcj20vm09paco.jpg" alt="学习算法原始形式"></p><ul><li>采用<strong>随机梯度下降法</strong><br>随机梯度下降算法的具体应用。<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1ftn3445t8zj20ty0imgsp.jpg" alt="感知机学习算法原始形式"></li></ul><p>感知机学习算法由于采用不同的初值或选取不同的误分类点，解可以不同。<br>当训练数据集<a href="https://en.wikipedia.org/wiki/Linear_separability" target="_blank" rel="noopener">线性可分</a>时，感知机学习算法原始形式迭代是收敛的(一定有解)</p><h3 id="感知机学习算法对偶形式"><a href="#感知机学习算法对偶形式" class="headerlink" title="感知机学习算法对偶形式"></a>感知机学习算法对偶形式</h3><p>对偶形式的目的是降低运算量：样本点的特征向量以内积的形式存在于感知机对偶形式的算法中，因此，如果事先计算好所有的内积，也就是Gram矩阵，就可以大大地加快计算速度。<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1ftnalbv4cvj20mn0fa0uo.jpg" alt="感知机对偶形式内容"><br><img src="http://ww1.sinaimg.cn/large/7f349269ly1ftnajuec9lj20ob0obwfu.jpg" alt="感知机对偶形式算法"></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 梯度下降 </tag>
            
            <tag> 感知机 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>梯度下降</title>
      <link href="/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
      <url>/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
      <content type="html"><![CDATA[<p>梯度下降是机器学习中非常重要的一种方法。</p><h2 id="什么是梯度"><a href="#什么是梯度" class="headerlink" title="什么是梯度"></a>什么是梯度</h2><p>标量场中某一点的梯度指向在这点标量场增长最快的方向<br>梯度的绝对值是长度为1的方向中函数最大的增加率<br>以下为引出梯度的逻辑顺序（高等数学）：</p><ul><li>导数: 一元函数变化率</li><li>偏导数: 多元函数 函数沿坐标轴方向的变化率</li><li>方向导数: 多元函数，函数沿任意方向的变化率  </li><li>梯度: 是一个向量，方向是方向导数取得最大值的方向，模等于方向导数的最大值。</li></ul><h2 id="什么是梯度下降法-Gradient-Descent"><a href="#什么是梯度下降法-Gradient-Descent" class="headerlink" title="什么是梯度下降法(Gradient Descent)"></a>什么是梯度下降法(Gradient Descent)</h2><p>明白了梯度的概念，对于梯度下降法的概念也很容易理解了。梯度是增长最快的方向，只需要向梯度相反的方向就是函数下降最快的方向(垂直方向增长率为0)，不断向梯度下降最快的方向移动可以求出局部极小值。<br><a href="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95" target="_blank" rel="noopener">梯度下降法</a>（英语：Gradient descent）是一个一阶最优化算法，通常也称为最速下降法。 要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度（或者是近似梯度）的反方向的规定步长距离点进行迭代搜索。    </p><h2 id="什么是随机梯度下降法-Stochastic-Gradient-Descent"><a href="#什么是随机梯度下降法-Stochastic-Gradient-Descent" class="headerlink" title="什么是随机梯度下降法 (Stochastic Gradient Descent)"></a>什么是随机梯度下降法 (Stochastic Gradient Descent)</h2><p>与梯度下降不同，随机梯度下降就是每次只随机选取一个样本，用这个样本来寻找下降的梯度。虽然这样子不如梯度下降精确，但是这样可以在前期更快的下降，而且结果也是在极小值附近。但是到后期可能会在极值点左右摆动。</p><h2 id="什么是批量梯度下降-Batch-Gradient-Descent"><a href="#什么是批量梯度下降-Batch-Gradient-Descent" class="headerlink" title="什么是批量梯度下降(Batch Gradient Descent)"></a>什么是批量梯度下降(Batch Gradient Descent)</h2><p>介于梯度下降与随机梯度下降之间的一种方法。梯度下降选取所有的样本，随机梯度下降只选取一个样本，批量梯度下降则选取一个批量的样本来计算梯度。</p><h2 id="随机梯度下降与梯度下降比较-随机梯度下降的优势"><a href="#随机梯度下降与梯度下降比较-随机梯度下降的优势" class="headerlink" title="随机梯度下降与梯度下降比较(随机梯度下降的优势)"></a>随机梯度下降与梯度下降比较(<a href="https://zhuanlan.zhihu.com/p/28060786" target="_blank" rel="noopener">随机梯度下降的优势</a>)</h2><ul><li>相对于非随机算法，SGD 能更有效的利用信息，特别是信息比较冗余的时候。</li><li>相对于非随机算法， SGD 在前期迭代效果卓越。</li><li>如果样本数量大，那么 SGD的Computational Complexity 依然有优势。</li></ul>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 梯度下降 </tag>
            
            <tag> 算法，统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划</title>
      <link href="/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<p>动态规划的基本内容</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>动态规划算法并非适用于所有的最优化问题(还有其他算法，例如贪心算法),适用于动态规划求解的问题应具备两个基本要素:<strong>最优子结构性质</strong>和<strong>子问题重叠性质</strong>。<br>动态规划的本质是对<strong>问题状态</strong>的定义和问题<strong>状态转移方程</strong>的定义<br>动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p><ul><li><strong>子问题重叠性质</strong>：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</li><li><p><strong>无后效性</strong>:如果在某个阶段上过程的状态已知，则从此阶段以后过程的发展变化仅与此阶段的状态有关，而与过程在此阶段以前的阶段所经历过的状态无关。</p></li><li><p><strong>最优子结构性质</strong>：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。<br>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）<br>最优子结构性质,通俗地讲就是问题的最优解包含其子问题的最优解。也就是说,如果把问题的最优解分解(比如划分为两个或者多个部分,或者删除第一个或者最后一个分量),得到一个子解,那么这个子解是特定子问题的最优解。最优子结构性质隐含了问题最优解和子问题最优解之间的一种递推关系。它是动态规划的基础,保障了问题的最优解可以由子问题的最优解构造得到,即得到动态规划算法的递推方程。如果一个问题不具备该性质,则不可能用动态规划方法来求解。在分析问题的最优子结构性质时,人们一般采用反证法:首先假设由问题最优解S导出的子问题的解不是最优的,然后再推导在这个假设下可构造出比S更好的解S’,从而得到矛盾。<br>分治算法求解问题时,每次产生的子问题并不总是新问题,有些子问题重复出现,这种性质称为子问题重叠性质。<br>在动态规划算法中,对于重复出现的子问题,只是在第一次遇到时执行求解过程,然后把求解结果保存在一个表格(可能是高维表格)中,再遇到这个子问题时,直接从表格中引用答案,从而避免重复计算,达到提高效率的目标。<br>需要提醒的是,子问题重叠性质不是动态规划适用的必要条件,但是如果该性质不满足时,动态规划方法与其他方法相比就不具备优势。</p></li></ul><hr><h3 id="另一种理解"><a href="#另一种理解" class="headerlink" title="另一种理解"></a>另一种理解</h3><blockquote><ul><li>每个阶段只有一个状态-&gt;<strong>递推</strong>；  </li><li>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;<strong>贪心</strong>；  </li><li>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;<strong>搜索</strong>；  </li><li>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;<strong>动态规划</strong>。   </li></ul></blockquote><p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做<strong>最优子结构</strong>；<br>而不管之前这个状态是如何得到的这个性质叫做<strong>无后效性</strong>。</p><hr><h2 id="动态规划计算方法"><a href="#动态规划计算方法" class="headerlink" title="动态规划计算方法"></a>动态规划计算方法</h2><ul><li>递归  </li><li>自顶向下的备忘录法（不一定最优）<br>从上开始，将已经计算过的内容存储起来</li><li>自底向上<br>从最初的，最底层的内容开始，从小计算到大</li></ul><p>动态规划算法设计步骤<br>动态规划算法适合用于求解最优化问题,通常可按下列步骤来设计动态规划算法:</p><blockquote><ol><li>分析最优子结构性质;</li><li>确定状态表示和状态递推方程,递归地定义最优值;</li><li>确定状态转移顺序,以自底向上的方式计算出最优值;</li><li>根据计算最优值时得到的信息,构造最优解。</li></ol></blockquote><p>第(1)步是基础,也是关键。在分析最优子结构性质时,子解分解和子解对应的子问题描述是关键。本书将介绍两种子解分解方法:基于划分的方法和基于减一的方法。在第一种方法中,问题的最优解依据问题性质划分成两个或者多个子解,但是其划分位置无法事先确定;在第二种方法中,问题的最优解依据问题性质缩减规模,比如减去最优解的第一个分量,或者最后一个分量,得到规模少1个单位的子解。得到子解后,分析和描述该子解对应的子问题,如果能证明该子解是对应子问题的最优解,则该问题满足最优子结构性质,转入第(2)步;否则,该问题不能用动态规划求解。</p><p>第(2)步是动态规划算法的核心,它是最优解的规划过程。状态表示本质上就是子问题的表示,形如f(x1,…,xk),其中x1,…,xk 是描述子问题的参数列表,每一个参数都需要定义其取值范围;f(·)的值域则体现问题的求解目标,一般地,f(·)直接定义为待求解问题的目标值。需要注意的是,对于有些问题来说,f(·)如果直接定义为原问题目标值,可能最优子结构性质不成立。此时,f(·)往往定义为某个中间目标值,比如最大上升子序列问题。在算法实现时,状态f(x1,…,xk)一般用一个k 维的表格存储,动态规划过程就是表格操作过程。</p><p>第(3)步体现了动态规划算法的执行过程。通俗地讲,动态规划是一个由易至难的求解过程:先求解最简单的子问题的解,然后利用简单子问题的解构造复杂一些的子问题的解,直至求解原问题的解。</p><p>第(4)步是可选步骤,只有问题要求构造最优解时才需要。</p><hr><h3 id="贪心算法与动态规划"><a href="#贪心算法与动态规划" class="headerlink" title="贪心算法与动态规划"></a><a href="https://blog.csdn.net/jarvischu/article/details/6056387" target="_blank" rel="noopener">贪心算法与动态规划</a></h3><p><del>自己的理解：贪心就是一直选最优最终就是最优的。动态规划是每个小问题做最优，不是从最初选最优就是最优的。</del></p><p>求最优解的问题，从根本上说是一种对解空间的遍历。最直接的暴力分析容易得到，最优解的解空间通常都是以指数阶增长，因此暴力穷举都是不可行的。<br>最优解问题大部分都可以拆分成一个个的子问题，把解空间的遍历视作对子问题树的遍历，则以某种形式对树整个的遍历一遍就可以求出最优解，如上面的分析，这是不可行的。<br>贪心和动态规划本质上是对子问题树的一种修剪。两种算法要求问题都具有的一个性质就是“子问题最优性”。即，组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的。如果以自顶向下的方向看问题树（原问题作根），则，我们每次只需要向下遍历代表最优解的子树就可以保证会得到整体的最优解。形象一点说，可以简单的用一个值（最优值）代表整个子树，而不用去求出这个子树所可能代表的所有值。<br>动态规划方法代表了这一类问题的一般解法。我们自底向上（从叶子向根）构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，其它的值舍弃。动态规划的代价就取决于可选择的数目（树的叉数）和子问题的的数目（树的节点数，或者是树的高度？）。<br>贪心算法是动态规划方法的一个特例。贪心特在，可以证明，每一个子树的根的值不取决于下面叶子的值，而只取决于当前问题的状况。换句话说，不需要知道一个节点所有子树的情况，就可以求出这个节点的值。通常这个值都是对于当前的问题情况下，显而易见的“最优”情况。因此用“贪心”来描述这个算法的本质。由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。这样，与动态规划相比，它的代价只取决于子问题的数目，而选择数目总为1。</p><hr><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a><a href="http://www.cppblog.com/menjitianya/archive/2015/10/23/212084.html" target="_blank" rel="noopener">习题</a></h2><p><strong>线性模型:指状态的排布是呈线性的</strong></p><h3 id="习题1-小朋友过桥问题"><a href="#习题1-小朋友过桥问题" class="headerlink" title="习题1 小朋友过桥问题"></a>习题1 小朋友过桥问题</h3><p>在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。</p><blockquote><p>我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以opt[i] = opt[i-1] + a[1] + a[i] (让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)<br>如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以<br>opt[i] = opt[i-2] + a[1] + a[i] + 2*a[2] (让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题)<br>所以 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2*a[2] }</p></blockquote><h3 id="习题2-最长单调子序列问题"><a href="#习题2-最长单调子序列问题" class="headerlink" title="习题2 最长单调子序列问题"></a>习题2 最长单调子序列问题</h3><p>给定一个长度为n(1 &lt;= n &lt;= 1000)的整数序列a[i]，求它的一个子序列(子序列即在原序列任意位置删除0或多个元素后的序列)，满足如下条件：<br>      1、该序列单调递增；<br>      2、在所有满足条件1的序列中长度是最长的；</p><blockquote></blockquote><h3 id="习题2-回文串问题（区间模型）"><a href="#习题2-回文串问题（区间模型）" class="headerlink" title="习题2 回文串问题（区间模型）"></a>习题2 回文串问题（区间模型）</h3><p>给定一个长度为n（n &lt;= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。</p><h3 id="习题3-背包问题（背包模型）"><a href="#习题3-背包问题（背包模型）" class="headerlink" title="习题3 背包问题（背包模型）"></a>习题3 背包问题（背包模型）</h3><p>有N种物品（每种物品1件）和一个容量为V的背包。放入第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。f[i][v]表示前i种物品恰好放入一个容量为v的背包可以获得的最大价值。决策为第i个物品在前i-1个物品放置完毕后，是选择放还是不放，状态转移方程为：</p>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法</title>
      <link href="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>基于网络课程和《数据结构与算法分析——Java语言描述》，基本排序算法的讲解，以及Java代码实现。<br><a id="more"></a><br>O(n²) 时间复杂度<br>虽然时间复杂度相对较高，但是同样也有好处</p><ul><li>编码相对简单</li><li>在某些情况下，这些算法反而更有效</li><li>可以从简单的方法中衍生出复杂的算法</li><li>作为子过程，经过修改变为复杂的算法</li></ul><p>重要的思想：<br><strong>逆序数</strong>：排序的过程就是消除逆序数的过程，所以逆序数的个数影响排序的性能(也可以从这个角度来思考排序的性能)  </p><ul><li>N个互异数的数组的平均逆序数是 $ N(N-1)/4 $(数对的一半)  </li><li>通过交换相邻元素进行排序的任何算法平均都需要 $ Ω(N^2) $  </li><li>对于归并排序，归并过程中，可以一次消除多个逆序数，提高算法效率。</li></ul><h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序 Selection Sort"></a>选择排序 Selection Sort</h3><p>从未排序的数组中逐一选择最小的元素进行排序<br><strong>KEY：寻找数组中最小的元素</strong><br>大约需要 $\frac{N^2}{2}$次比较和N次交换<br>可以考虑对算法进行升级，不仅仅对整型进行排序，对浮点型甚至对对象进行排序（采用Comparable接口，然后通过compareto进行比较）<br><strong>特点：</strong></p><ul><li>运行时间和输入无关(这样对于最开始就基本有序的数组就没有优势了)  </li><li>数据移动最少 </li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><pre><code class="Java">public class SelectionSort{    public static void SelectionSort(Comparable[] arr) {        int n = arr.length;        for (int i = 0; i &lt; n; i++) {            int minindex = i;            //注意是从i+1开始的            for (int j = i + 1; j &lt; n; j++) {                if(arr[j].compareTo(arr[minindxe]) &lt; 0){                    minindex = j;                }            }            swap(arr,minindex,i);        }    }    public static void swap(Object[] arr, int i, int j){        Object e = arr[i];        arr[i] = arr[j];        arr[j] = e;    }}</code></pre><h4 id="选择排序优化"><a href="#选择排序优化" class="headerlink" title="选择排序优化"></a>选择排序优化</h4><p>优化前，一次遍历仅仅可以找到最小的排好序，优化后，一次遍历可以找到最小的以及最大的两个元素排好序</p><pre><code class="java">public class SelectionSort {    public static void selectionSort(Comparable[] arr) {        int n = arr.length;        int left = 0, right = n - 1;        while(left &lt; right){            int minindex = left, maxindex = right;            if(arr[minindex].compareTo(arr[maxindex]) &gt; 0)                swap(arr, minindex, maxindex);                //注意i的范围            for(int i = left + 1; i &lt; right; i++) {                if (arr[i].compareTo(arr[minindex]) &lt; 0) {                    minindex = i;                }                if (arr[i].compareTo(arr[maxindex]) &gt; 0) {                    maxindex = i;                }            }            swap(arr, left, minindex);            swap(arr, right, maxindex);            left++;            right--;        }    }}</code></pre><h3 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h3><p>插入排序由N-1趟排序组成。对于p到N-1趟，插入排序保证从位置0到位置p上的元素为已排状态。<br><strong>KEY:比前面一个小就进行交换，否则结束这一次插入(比选择排序优秀的地方，可以提前结束)</strong>  </p><ul><li>平均情况下，插入排序需要$\frac{N^2}{4}$次比较与$\frac{N^2}{4}$次交换  </li><li>逆序数思考维度，每一次交换都是在减少一个逆序数，那么就需要逆序数次交换。</li><li><p>对插入排序进行优化：之前的插入排序每一次插入都要进行很多次交换，然而每次交换都是三次赋值的时间，所以很浪费时间，这样可以牺牲一个时间复杂度，将要插入的元素跟之前的元素进行比较，但是先不交换，等到找到要交换的元素，再进行一次交换，这样每一次插入都只进行一次交换。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>插入排序为$O(n^2)$,如果输入数组时反序的时候，复杂度为$\Theta(N^2)$,如果输入已经预先排序，那么复杂度为$O(N^2)$。正因如此<strong>如果输入几乎被排序，那么插入排序将运行的更快。</strong></p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><pre><code class="java">public class InsertionSort{  public static void insertionSort(Comparable arr) {      int n = arr.length;      for(int i = 0; i &lt; n; i++) {          // 寻找元素arr[i]合适的插入位置          // 写法1          // for( int j = i ; j &gt; 0 ; j -- )          //    if( arr[j].compareTo( arr[j-1] ) &lt; 0 )          //        swap( arr, j , j-1 );          //    else          //        break;          // 写法2//            for( int j = i; j &gt; 0 &amp;&amp; arr[j].compareTo(arr[j-1]) &lt; 0 ; j--)//                swap(arr, j, j-1);          // 写法3          // 改进的插入算法，利用赋值替代交换，减少时间消耗          Comparable e = arr[i];          int j = i;          for( ; j &gt; 0 &amp;&amp; arr[j-1].compareTo(e) &gt; 0 ; j--)              arr[j] = arr[j-1];          arr[j] = e;      }  }  public static void swap(Object[] arr, int i, int j){      Object e = arr[i];      arr[i] = arr[j];      arr[j] = e;  }}</code></pre></li></ul><h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 Bubble Sort"></a>冒泡排序 Bubble Sort</h3><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。  </p><pre><code class="java">public class ShellSort {    private ShellSort() {    }    /**     * 希尔排序算法     */    public static void sort(Comparable[] arr) {        int n = arr.length;        int h = 1;        while (h &lt; n / 3) {            h = 3 * h + 1;        }        while (h &gt;= 1) {            // 排序是从h到n            for (int i = h; i &lt; n; i++) {                Comparable e = arr[i];                int j = i;                for (; j &gt;= h &amp;&amp; e.compareTo(arr[j - h]) &lt; 0; j -= h) {                    arr[j] = arr[j - h];                }                arr[j] = e;            }            h /= 3;        }    }    /**     * 测试用例     */    public static void main(String[] args) {        int N = 1000000;        Integer[] arr = SortTestHelper.generateRandomArray(N, 0, 100000);        SortTestHelper.testSort(&quot;sort.ShellSort&quot;, arr);    }}</code></pre><h3 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序 Shell Sort"></a>希尔排序 Shell Sort</h3><ul><li>希尔排序通过比较一定间隔的元素来工作，，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。  </li><li>$h_k$排序的一般做法是，对于$h_k$，$h_{k+1}$，···$N-1$中的每一个位置<em>i</em>,把其上的元素放到<em>i</em>，$i-h_k$,$i-2h_k$,···中的正确位置上。<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4></li><li>希尔排序的一个重要性质就是一个$h_k$排序的文件保持它的$h_k$排序性(我的理解就是，经过$h_k$排序后，逆序对不会再增加)  </li><li>使用希尔增量时希尔排序的最坏情形运行时间为$\Theta(N^2)$<pre><code class="java">public class ShellSort {  privata ShellSort(){}  public static void shellSort(Comparable[] arr){      for(int gap = arr.length/2; gap &lt; arr.length; gap /= 2) {          for(int i = gap; i &lt; arr.length; i++) {              // 使用插入排序              Comparable[] temp = arr[i];              int j = i;              for(; j &gt;= gap &amp;&amp; temp.compareTo(arr[j - gap]) &lt;0; j-=gap){                  a[j] = a[j - gap];              }              a[j] = temp;          }      }  }}</code></pre></li></ul><hr><p>O(nlgn)复杂度的排序算法<br>分治算法的思想(分而治之)  </p><blockquote><p>归并排序 重点在合(如何合)<br>快速排序 重点在分(如何分)  </p></blockquote><h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h3><p><strong>KEY：将两个有序的数组合并为一个有序的数组</strong><br>牺牲了存储空间，获得了时间上的减少。<br>首先进行分层，然后对每一层使用归并排序<br><strong>归并排序的逻辑</strong>  递归的思想，这也是递归的一个很好的例子。对于递归的效率分析也是一个很好的技巧(叠缩求和与带入法)<br><strong>优化：</strong></p><ul><li>对近乎有序的数组进行优化要判断要不要进行归并</li><li>由于对于小数据量的元素使用插入排序更加迅速， 所及可以考虑分层进行到一部分的时候改用插入排序(一部分是怎么确定的？)</li></ul><p>优化后的归并排序</p><pre><code class="java">public class MergeSort {    private MergeSort() {    }    /**     * 递归使用归并排序，对arr[l...r]的范围进行排序     */    private static void sort(Comparable[] arr, int l, int r) {        /*if(l&gt;=r){            return;        }*/        // 优化2：在归并到一定程度的时候使用插入排序        int size = 15;        if (r - l &lt;= size) {            insertionSort(arr, l, r);        }        // int mid = (r - l) / 2 + l;        int mid = (l + r) / 2;        sort(arr, l, mid);        sort(arr, mid + 1, r);        // 优化1：如果已经有序就不进行归并了。        if (arr[mid].compareTo(arr[mid + 1]) &gt; 0) {            merge(arr, l, mid, r);        }    }    /**     * 将arr[l...mid]和arr[mid+1...r]两部分进行归并     */    private static void merge(Comparable[] arr, int l, int mid, int r) {        //拷贝一个数组赋值用(牺牲空间复杂度，降低时间复杂度)        //注意还有个+1        Comparable[] aux = Arrays.copyOfRange(arr, l, r + 1);                // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1        int i = l, j = mid + 1;        for (int k = l; k &lt;= r; k++) {            // 如果左半部分元素已经全部处理完毕            if (i &gt; mid) {                // j - l很关键                arr[k] = aux[j - l];                j++;                // 如果右半部分元素已经全部处理完毕            } else if (j &gt; r) {                arr[k] = aux[i - l];                i++;                // 左半部分所指元素 &lt; 右半部分所指元素            } else if (aux[i - l].compareTo(aux[j - l]) &lt; 0) {                arr[k] = aux[i - l];                i++;                // 左半部分所指元素 &gt;= 右半部分所指元素            } else {                arr[k] = arr[j - l];                j++;            }        }    }    private static void insertionSort(Comparable[] arr, int l, int r) {        for (int i = l + 1; i &lt;= r; i++) {            int j = i;            Comparable e = arr[j];            for (; j &gt; l; j--) {                if (e.compareTo(arr[j - 1]) &lt; 0) {                    arr[j] = arr[j - 1];                } else {                    break;                }            }            arr[j] = e;        }    }}</code></pre><h4 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h4><p>不使用递归，只用迭代性能相对来说要差一点点<br>并没有使用到数组的特性(通过下标寻找元素)，所以对于链表很适用。<br>对于数组要思考到越界的问题  </p><pre><code class="java">public class MergeSortBUAdvanced{    /**     * 自底向上归并排序优化     * 1、在size小的时候采用插入排序     * 2、如果归并之前已经有序，则不进行归并     */    public static void sort(Comparable[] arr) {        int n = arr.length;        // 设置size，低于这个size使用插入排序        int size = 16;        // 优化1： 小数组使用插入排序更优化        for (int i = 0; i &lt; n; i += size) {            insertionSort(arr, i, Math.min(i + size - 1, n - 1));        }        for (; size &lt; n; size += size) {            for (int i = 0; i + size  &lt; n; i += size + size) {                // 优化2： 如果之前已经有序，则不进行归并                if (arr[i + size - 1].compareTo(arr[i + size]) &gt; 0) {                    merge(arr, i, i + size - 1, Math.min(i + size + size - 1, n - 1));                }            }        }    }    private static void merge(Comparable[] arr, int l, int mid, int r) {        Comparable[] aux = Arrays.copyOfRange(arr, l, r + 1);        int i = l, j = mid + 1;        for (int k = l; k &lt;= r; k++) {            if (i &gt; mid) {                arr[k] = aux[j - l];                j++;            } else if (j &gt; r) {                arr[k] = aux[i - l];                i++;            } else if (aux[i - l].compareTo(aux[j - l]) &lt; 0) {                arr[k] = aux[i - l];                i++;            } else {                arr[k] = aux[j - l];                j++;            }        }    }    // 优化中使用的插入排序    private static void insertionSort(Comparable[] arr, int l, int r) {        for (int i = l; i &lt;= r; i++) {            Comparable e = arr[i];            int j = i;            for (; j &gt; l; j--) {                if (e.compareTo(arr[j - 1]) &lt; 0) {                    arr[j] = arr[j - 1];                } else {                    break;                }            }            arr[j] = e;        }    }}</code></pre><h4 id="问题：求逆序数个数"><a href="#问题：求逆序数个数" class="headerlink" title="问题：求逆序数个数"></a>问题：求逆序数个数</h4><p>对递归的理解很关键，通过运用归并排序的方法，使得求逆序数的复杂度变为 $O(nlogn$</p><pre><code class="java">public class InversionCount{    /**     * 递归排序(用作分割)     */    public static long sort(Comparable[] arr, int l, int r) {        if (l &gt;= r) {            return 0L;        }        int mid = l + (r - l) / 2;        // 求出 arr[l...mid] 范围的逆序数        long countl = sort(arr, l, mid);        // 求出 arr[mid+1...r] 范围的逆序数        long countr = sort(arr, mid + 1, r);        // 两个count分别是上一个merge的结果，这就相当于将所有的merge结果相加        return countl + countr + merge(arr, l, mid, r);    }    /**     * 合并操作,就是一个排序的过程     */    private static long merge(Comparable[] arr, int l, int mid, int r) {        // 逆序数对个数初始化        long count = 0L;        // merge操作        Comparable[] aux = Arrays.copyOfRange(arr, l, r + 1);        int i = l, j = mid + 1;        for (int k = l; k &lt;= r; k++) {  // 如果左半部分元素已经全部处理完毕            if (i &gt; mid) {                arr[k] = aux[j - l];                j++;            } else if (j &gt; r) {  // 如果右半部分元素已经全部处理完毕                arr[k] = aux[i - l];                i++;            } else if (aux[j - l].compareTo(aux[i - l]) &gt;= 0) {  // 左半部分所指元素 &lt;= 右半部分所指元素                arr[k] = aux[i - l];                i++;            } else { // 右半部分所指元素 &lt; 左半部分所指元素                arr[k] = aux[j - l];                j++;                // 此时, 因为右半部分j所指的元素小                // 这个元素和左半部分的所有未处理的元素都构成了逆序数对(不包括右边的是因为右边的在上一次迭代的时候已经计算过了)                // 左半部分此时未处理的元素个数为 mid - i + 1(注意i的意思，i是将要处理的元素)                count = count + (long) (mid - i + 1);            }        }        return count;    }}</code></pre><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 Quick Sort"></a>快速排序 Quick Sort</h3><p><strong>key:如何将数组分为大小两个(Partition)</strong><br>递归思想，分别使用快速排序<br>围绕着枢纽元进行大小分离，不进行排序，只区分大小  </p><h4 id="简单快速排序-注意数组的边界"><a href="#简单快速排序-注意数组的边界" class="headerlink" title="简单快速排序(注意数组的边界)"></a>简单快速排序(注意数组的边界)</h4><blockquote><ol><li>首先确定元素$v$</li><li>遍历数组(j是$&lt;v$的尾部，i是$&gt;v$的尾部,e是遍历的元素)<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q319266j20vj0boabm.jpg" alt="快速排序结构1"></li><li>遍历一遍的数组结构<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q3h2frpj20wv09q3zv.jpg" alt="快速排序结构2"></li><li>最终的结构，j是选定元素的下标，左边是小于$v$的元素，右面是大于$v$的元素<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q3uhlivj20wr09fq4d.jpg" alt="快速排序结构3"></li></ol></blockquote><pre><code class="java">public class QuickSort{    public static void quickSort(Comparable[] arr, int l, int r){        // 递归的基准情况        if (l &gt;= r) {            return;        }        // partion操作，移动元素，找到中值的位置        Comparable v = arr[l];        int j = l;        for (int i = l + 1; i &lt;= r; i++) {            if (arr[i].compareTo(v) &lt; 0) {                j++;                swap(arr, j, i);            }         }        swap(arr, l, j);        j--;        // 进行递归        quickSort(arr, l, j);        quickSort(arr, j + 2, r);    }    // 交换函数    private static void swap(Comparable[] arr, int i, int j) {        Comparable temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}</code></pre><h4 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h4><p>重点关注列表中下标的位置，根据整个流程来编写程序，同时在分界点，根据下标来区分。</p><ol><li>底层可以采用插入排序的算法进行优化</li><li>针对 <strong>近乎有序</strong> 数组的优化。和归并排序比较，都是利用递归，同样将数组一分为二，但是归并左右两部分是平衡的而快速排序却不是(根据元素的选择)。 不再采用第一个元素为中间值，采用随机选取元素作为中间值。</li><li>针对有 <strong>重复元素</strong> 的数组进行的优化。由于在对数组进行分类的时候，与中间值相等的元素并没有进行考虑，所以仍旧被分到了两侧，这样下一次排序仍然要对这些元素进行比较，导致速度很慢。 可以考虑在分类的时候，将大的元素从后往前放置，小的元素从前往后放置，将与中间值相等的元素分散到两侧，这样对于有大量的相同元素的数组可以避免一边数据量很大造成不平衡。  <blockquote><ul><li>新的算法思想<span id="QuickSort2Ways">(QuickSort2Ways)</span></li></ul><ol><li>改变放置的方式<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q488vs0j20w509ldh6.jpg" alt="QuickSortAdvanced"></li><li>继续从i开始向后遍历元素，直到找到元素$&gt;=v$。<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q4g2bwjj20vy09qjt4.jpg" alt="QuickSortAdvanced"></li><li>继续从j开始向前遍历元素，直到找到元素$&lt;=v$。<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q4lud9nj20vo0bt40t.jpg" alt="QuickSortAdvanced"></li><li>然后交换i的元素和j的元素<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q4rc4a1j20vi0bgwgb.jpg" alt="QuickSortAdvanced"></li><li>继续遍历，直到i=j遍历完成</li></ol></blockquote></li></ol><pre><code class="java">public class QuickSort2Ways {   public static void QuickSort2Ways(Comparable[] arr, int l, int r) {        // 优化：小数组采用插入排序, 递归的基准情况        int size = 16;        if (r - l &lt;= size - 1) {            insertionSort(arr, l, r);            return;        }        // 优化：随机选择中间值，避免过多相同元素的情况        swap(arr, l, (int) Math.random() * (r - l + 1) + l);        // 优化：两路排序        Comparable v = arr[l];        int i = l + 1, j = r;        while (true) {            // 为什么是 &lt; 不是 &lt;= 的思考(http://coding.imooc.com/learn/questiondetail/4920.html)            while (i &lt;= r &amp;&amp; arr[i].compareTo(v) &lt; 0) {                i++;            }            while (j &gt;= l + 1 &amp;&amp; arr[j].compareTo(v) &gt; 0) {                j--;            }            // 跳出循环            if (i &gt; j) {                break;            }            swap(arr, i, j);            i++;            j--;        }        swap(arr, l, j);        // 递归调用        sort(arr, l, j - 1);        sort(arr, j + 1, r);    }    private static void swap(Comparable[] arr, int i, int j) {        Comparable temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }    private static void insertionSort(Comparable[] arr, int l, int r) {        for (int i = l; i &lt; r; i++) {            Comparable e = arr[i];            int j = i;            for (; j &gt; l; j--) {                if (arr[j - 1].compareTo(e) &gt; 0) {                    arr[j] = arr[j - 1];                } else {                    break;                }            }            arr[j] = e;        }    }}</code></pre><ol start="4"><li>在<a href="#QuickSort2Ways">QuickSort2Ways</a>的基础之上对于选定元素相等的元素也进行分类，产生QuickSort3Ways.<blockquote><ul><li>终极算法QuickSort3Ways</li></ul><ol><li>开始的状态，同时维护3路元素，分别是$&gt;v$、$&lt;v$、$=v$。初始阶段如下图，注意边界的值！<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q7yg6ekj20w00by40n.jpg" alt="QuickSort3Ways"></li><li>如果元素$e$与元素$v$相等，则将i向后移动一位<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q849gtgj20wb0dpacd.jpg" alt="QuickSort3Ways"></li><li>如果元素$e$比元素$v$小，则将$e$与 =$v$ 的元素块第一个元素(lt+1)交换,i向后移动一位<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q8a53e0j20vw0dv40v.jpg" alt="QuickSort3Ways"></li><li>如果元素$e$比元素$v$大，则将$e$与 &gt;$v$ 的元素块第一个元素(gt-1)交换,i向后移动一位<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q8hd6gej20vy0duwgt.jpg" alt="QuickSort3Ways">    </li><li>最终的结果就是 i 与 gt 相等，遍历结束,最终还要讲lt位置的元素与第一个元素交换位置，得到最终的数组(如果不打算维护lt这个元素，要注意数组的边界位置)<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q8mook3j20w60cp0v3.jpg" alt="QuickSort3Ways"><br><img src="http://ww1.sinaimg.cn/large/7f349269ly1fu3q8r7kv1j20vo09jwgb.jpg" alt="QuickSort3Ways"></li></ol></blockquote></li></ol><pre><code class="java">public class QuickSort3Ways {    /**     * 3路快速排序算法     */    private static void QuickSort3Ways(Comparable[] arr, int l, int r) {        // 优化1：在小分组的时候使用插入排序        int size = 16;        if (r - l &lt;= size - 1) {            insertionSort(arr, l, r);            return;        }        // 优化2：随机选取元素的中间值，避免大量重复元素        swap(arr, l, (int) Math.random() * (r - l + 1) + l);        Comparable v = arr[l];        // gt从r+1开始        int lt = l, gt = r + 1, i = l + 1;        while (i &lt; gt) {            if(v.compareTo(arr[i]) &gt; 0) {                lt++;                swap(arr,i,lt);                i++;            } else if(v.compareTo(arr[i]) &lt; 0) {                // 交换了一个没有判断过的元素到i，所以i不用+1！                gt--;                swap(arr,i,gt);            } else {                // 两个元素相等的情况，不用进行交换                i++;            }        }        // 将第一个元素交换到=v的位置        swap(arr,l,lt);        lt--;        // 递归调用        sort(arr,l,lt);        sort(arr,gt,r);    }    /**     * 插入排序算法     */    public static void insertionSort(Comparable[] arr, int l, int r) {        for (int i = 1; i &lt; r - l + 1; i++) {            Comparable e = arr[i];            int j = i;            for (; j &gt; 0; j--) {                if (e.compareTo(arr[j - 1]) &lt; 0) {                    arr[j] = arr[j - 1];                } else {                    break;                }            }            arr[j] = e;        }    }    /**     * 交换函数     */    private static void swap(Comparable[] arr, int i, int j) {        Comparable temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}</code></pre><h4 id="问题：取出数组中第n大的元素"><a href="#问题：取出数组中第n大的元素" class="headerlink" title="问题：取出数组中第n大的元素"></a>问题：取出数组中第n大的元素</h4><p>如果利用先排序再找到第n个最大值，那么这个算法的复杂度为$O(nlogn)$,但是利用快速排序的思想可以很好的解决这个问题，使得复杂度变为$O(n)$</p><pre><code class="java">public static Comparable selection(Comparable[] arr, int k) {        int n = arr.length;        // 注意这里是k - 1，因为下标还包括0        return selection(arr, 0, n - 1, k - 1);}private static Comparable selection(Comparable[] arr, int l, int r, int k) {        // 避免函数越界        if (l == r) {            return arr[l];        }        swap(arr, l, (int) Math.random() * (r - l + 1) + l);        Comparable v = arr[l];        int j = l;        for (int i = l + 1; i &lt;= r; i++) {            if (arr[i].compareTo(v) &lt; 0) {                j++;                swap(arr, i, j);            }        }        swap(arr, l, j);        if (j  &lt; k) {            return selection(arr, j + 1, r, k);        } else if (j &gt; k) {            return selection(arr,l,j - 1,k);        } else {            return arr[j];        }    }    /**     * 交换函数     */    private static void swap(Comparable[] arr, int i, int j) {        Comparable temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }</code></pre><h3 id="堆排序-HeapSort"><a href="#堆排序-HeapSort" class="headerlink" title="堆排序 HeapSort"></a>堆排序 HeapSort</h3><p>重点在于堆这种数据结构<br>队列：<br>普通队列：按照时间顺序，先进先出，后进后出<br>优先队列：出队顺序和入队顺序和时间无关，和优先级有关</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><ol><li>N个互异数的数组的平均逆序数是$\frac{N(N-1)}{4}$</li><li>通过交换相邻元素进行排序的任何算法平均都需要$\Omega(N^2)$   <strong>一个排序算法通过删除逆序得以向前进行，而为了有效地进行，他必须使每次交换删除不止一个逆序</strong></li><li></li></ol>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写博客的原因</title>
      <link href="/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
      <url>/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>　　写博客这个事情我已经想了很久了，记得刚上大学的时候我就想着要写自己的博客，最开始还是想记录自己的生活，写一写随笔，因为我受高中老师的影响 ，平时也会写一写随笔的，但是由于自己不太想把自己的生活和自己的想法暴露给别人，所以自己一直没有写博客，再到后来，自己开始学习编程的知识，学习一些自己感兴趣的内容，写博客的想法又一次涌上心头，这一次不是分享自己的生活，这一次我想分享自己的学习成果。虽然说是成果，其实吧，更加像是自己对自己一种激励，或者说是自己对自己的一种监督。有了一个地方来记录自己的学习过程，并且可以被其他人看到，这对于自己来说是一个很好的鼓励，鼓励自己写一写东西。我还是一个很在意别人看法的人，所以，我可能会想着我自己有的博客，我一定要维护好，毕竟别人还会看见。让其他人觉得我很厉害。还有这也是我自己的一份记录。以前学习，我会画在书上，我会写在纸上，写上我对问题的思考，写上我的总结，但是最终会找不见，但是这次不一样了，有了自己的一块地方，我就可以把我的内容传到我自己的GitHub上，不仅仅别人可<br>以监督我写的内容，可以和别人进行讨论，同时，我自己还可以对自己学过的知识进行总结，进行记录。毕竟学过不一定会，总结，重复，才会让自己更强。督促我写这个博客还有另外一个因素，那就是我觉得很酷。我对一切很酷的东西都很感兴趣，像高中沉迷Lumia920，当时把照片贴在床板上，哈哈，督促我努力学习。博客也让我感觉很酷，普通的博客并不是，酷同时也有美的意思，就是我很喜欢的那种美，看到美的东西总让人很兴奋。这个博客还是自己搭建的，也让自己很有成就感。<br>　　当然这不是最终目标，我最终的目标是自己完全亲手搭建一个网站，拥有自己的域名，自己来维护，创造自己觉得美的东西，这让自己感觉很有动力。当然这需要很多的知识，虽然现在我还不具有这些知识，但是我会不断学习的，不断进步，让自己变得更强。<br>　　我始终喜欢那些很厉害的人。</p>]]></content>
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MarkDown使用指南</title>
      <link href="/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8markdown/"/>
      <url>/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8markdown/</url>
      <content type="html"><![CDATA[<p>我与markdown的渊源。</p><h2 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h2><p>　　主要还是因为Word不太好用，例如需要调整字体的间距，总觉得Word字体的间距太大了，不适合操作，而且其他方面编辑好以后如果需要加载到网页上，还涉及到格式转换的问题因此采用了markdown来书写，一个是书写文字非常方便，其次就是上传到自己的博客上也很方便，不涉及文字格式的从转换。</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>　　<del>我在Windows上使用的是<code>MarkDownPad</code>这款软件，其他软件我也没有使用过，首先这款软件很多人推荐，其次这款软件使用起来也很方便，很简洁。其次在很多地方都可以使用MarkDown，例如IDEA编译器也可以。</del><br>　　最近我开始使用vsCode来进行写作，不得不说真的是好用，颜色方面很有优势，看起来很舒服，还有各种插件，渲染完成的也很好，推荐。<br>　　看起来markdow使用比较繁琐，毕竟是一个新鲜的事物，我在第一次尝试的时候感觉很麻烦。但是当你真正使用起来，真正掏出30分钟来研究一下的话，还是很好上手的毕竟这仅仅是一个文本编辑器，最终还是要用来写字。  </p><h2 id="语法简述"><a href="#语法简述" class="headerlink" title="语法简述"></a>语法简述</h2><p>本文主要参考这份语法做出的简单整理<a href="http://xianbai.me/learn-md/article/extension/table.html" target="_blank" rel="noopener">MarkDown中文使用文档</a>  </p><ul><li><strong>标题</strong><br>使用<code>#</code> 来标识<br><code>#h1级标题</code><br><code>##h2级标题</code><br><code>###h3级标题</code><br><code>####h4级标题</code><br><code>#####h5级标题</code><br><code>######h6级标题</code></li><li><p><strong>列表</strong>（注意符号和文本之间增加一个空格）  </p><blockquote><ul><li>有序列表<br>使用<code>1.</code></li><li>无序列表<br>使用<code>*</code></li></ul></blockquote></li><li><p><strong>图片</strong><br><code>![链接名](链接)</code> 小括号中存放链接<br>note：<br>关于插入图片，由于markdown使用链接，所以我通常会使用图床来上传图片生成链接，推荐使用<code>新浪微博图床</code> 有专门的Chrome插件，非常方便。</p></li><li><strong>超链接</strong><br><code>[链接名](链接)</code> 小括号中存放链接</li><li><p><strong>代码</strong><br>使用 <code>`</code>包围代码，同时还可以利用名称来使代码高亮   </p><blockquote><p>```java<br>``` </p></blockquote></li><li><p><strong>引用</strong><br>在文本前加入 <code>&gt;</code> </p></li><li><strong>换行</strong><br>空格 + 空格 + 回车</li><li><strong>分割线</strong>  三个以上的短线<br>使用 <code>***</code>或者 <code>---</code>  </li><li><p><strong>删除线</strong><br>利用<code>~~删除的内容~~</code>设置删除线</p></li><li><p><strong>强调</strong><br><code>利用 *内容* 来进行斜体展示</code><br><code>利用 **内容** 来进行粗体展示</code></p></li><li><p><strong>表格</strong></p><blockquote><p> name | age<br> —　  | —<br> a　　| 10  </p></blockquote></li></ul><p>GitHub不支持表格…除非使用HTML语句</p><ul><li><strong>事项列表</strong>  <blockquote><p>- [ ] eat<br>- [x] eat<br>　　- [ ] eat</p></blockquote></li></ul><p>效果：  </p><blockquote><ul><li style="list-style: none"><input type="checkbox"> eat</li><li style="list-style: none"><input type="checkbox" checked> eat<ul><li style="list-style: none"><input type="checkbox"> eat</li></ul></li></ul></blockquote><ul><li><strong>版本控制语法</strong><br>与编写代码的语法类似，只不过代码的语言换成<code>diff</code>,同时以<code>+</code>开头表示新增，以<code>-</code>开头表示删除<br>似乎在博客上无法解析这个语法<br><code>`</code>diff</li></ul><ul><li>我是新增加的内容</li></ul><ul><li>我是减少的内容<br><code>`</code></li></ul>]]></content>
      
      <categories>
          
          <category> 有意思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同步、异步、阻塞、非阻塞</title>
      <link href="/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
      <url>/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
      <content type="html"><![CDATA[<p>“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。 </p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>　　同步与异步同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。<br>而异步则是相反，<em>调用</em>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。典型的异步编程模型比如Node.js<br>举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。  </p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>　　阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.<br>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。<br>还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Object 与 Objects</title>
      <link href="/Objects%E4%B8%8EObject/"/>
      <url>/Objects%E4%B8%8EObject/</url>
      <content type="html"><![CDATA[<p>看书看到Object,后来又看到了Objects,这两个非常相似，为了更加清晰的找出两者的不同，特地收录进来。</p><h2 id="Object（原始Object）"><a href="#Object（原始Object）" class="headerlink" title="Object（原始Object）"></a>Object（原始Object）</h2><p><strong>java.lang.Object</strong><br>所有的class都继承自Object类，这是所有类的父类。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>clone</li><li>equals</li><li>getClass</li><li>hashCode</li><li>toString  </li></ul><p>处理线程时才会被调用：  </p><ul><li>notify</li><li>notifyAll</li><li>wait</li><li>wait(long timeout)</li><li>wait(long timeout,int nanos)  </li></ul><p><strong>1. public final Class&lt;?&gt; getClass()</strong><br>final方法，不允许子类重写<br>返回<em>当前运行时</em>对象的Class对象（当前程序运行时怎么理解？？？）  </p><p><strong>2. public int hashCode()</strong><br>返回这个对象的哈希值（主要使用在hash table 、 HashMap）<br><strong>三大定律：</strong>   </p><blockquote></blockquote><ol><li>在java程序执行的过程中，一个对象在没有改变的情况下，无论被调用多少次，哈希码都是不变的（返回相同的整数值）  </li><li>如果用equals方法比较两个对象相等，则这两个对象一定返回相同的哈希值  </li><li>如果用equals方法比较两个对象不相等，两个对象的哈希值可能相等。但是不同的哈希值可以提高哈希表的性能。<br>由于所有类都是继承自Object类的，因此每一个对象都有hashcode方法。通常情况下，不同的对象产生的哈希值不同，因为默认的哈希值是通过hashcode方法导出的对象的存储地址。（那为什么还要重写hashcode方法？，直接用默认的不就可以了？？？？）  </li></ol><p><strong>3.public boolean equals(Object obj)</strong><br>比较两个对象是否相等，Object中默认的equals方法相当于比较两个对象的内存地址是否相等。  </p><blockquote></blockquote><ul><li>reflexive，自反性。任何<em>非空</em>引用值x，对于x.equals(x)必须返回true  </li><li>symmetric，对称性。任何<em>非空</em>引用值x和y，如果x.equals(y)为true，那么y.equals(x)也必须为true  </li><li>transitive，传递性。任何<em>非空</em>引用值x、y和z，如果x.equals(y)为true并且y.equals(z)为true，那么x.equals(z)也必定为true  </li><li>consistent，一致性。任何<em>非空</em>引用值x和y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改  </li><li>对于任何<em>非空</em>引用值 x，x.equals(null) 都应返回 false  </li></ul><p>如果重写equals方法，通常需要重写hashcode方法。<br>默认的equals方法中，如果两个非空引用值引用同一个对象，则equals方法返回true。  </p><p>较完美重写equals方法（Object类中，与Objects类不同）：  </p><blockquote><p>假定传入参数为otherObject。  </p><ol><li>首先检查this与otherObject是否引用同一个对象。<br>if (this == otherObject) return true;<br>这是一个优化，也是一种常用的形式。因为计算这个等式的代价要比一个一个比较类中的域付出的代价小得多。  </li><li>检查otherObject是否为null，是则为false，这个检查很有必要。<br>if (otherObject == null) return false;  </li><li>比较this和otherObject是否属于同一个类。如果equals语义在每个子类中有所改变（由子类决定相等的概念），就使用getClass检测。<br>if (getClass != otherObject.getClass()) return false;<br>如果所有子类都拥有统一的语义（由超类决定相等的概念），就使用<a href="http://www.cnblogs.com/rodney/archive/2005/08/18/instanceof.html" target="_blank" rel="noopener">instanceof（）</a>检测。<br>if (!(otherObject instanceof ClassName）) return false;  </li><li>将otherObject转化为相应的类类型变量。<br>ClassName other = (ClassName) otherObject  </li><li>使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，则返回true，否则返回false。<br>return field1 == other.field1 &amp;&amp; field2.equals(other.field2) &amp;&amp; …<br>如果在子类中重新定义equals，就要在其中包含调用super.equals(other)  </li></ol></blockquote><p><strong>4. protected Object clone() throws CloneNotSupportedException</strong><br>创建并返当前对象的一份拷贝<br><em>通常情况下</em> <code>x.clone() != x</code> 会是真； <code>clone().getClass() == x.getClass()</code> 也会是真；同时 <code>x.clone().equals(x)</code> 也会是真。<br>Object本身没有实现Cloneable接口，所以如果没有直接重写的话会产生错误（CloneNotSupportedException）。<br>如果要使用Clone方法需要继承Cloneable接口，同时重写Clone方法，通常是super.clone()<br>例：</p><pre><code> @Overridepublic Object clone() throws  CloneNotSupportedException{Father father = (Father)super.clone();return father;}</code></pre><p>同时还要注意深复制和浅复制的问题。<br>还没有解决的问题，关于数组的方法  <em>对于数组而言，clone方法都是浅复制方法。</em></p><p><strong>5.public String toString()</strong><br>返回表时对象值得字符串</p><pre><code>public String toString() {return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());}</code></pre><p>例如原生toString方法：</p><pre><code>Clone.Father@677327b6  </code></pre><p>官方推荐所有的Object子类都重写toString方法。  </p><h2 id="Objects（继承自Object）"><a href="#Objects（继承自Object）" class="headerlink" title="Objects（继承自Object）"></a>Objects（继承自Object）</h2><p><strong>java.util.Objects</strong>  </p><ol><li>全部是静态方法  </li><li>在计算hash code，返回字符串，比较两个object时，包括了null 的安全方法（不用验证null）</li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA强制类型转换</title>
      <link href="/Java%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/Java%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>有关Java中的强制类型转换问题</p><h2 id="转换分类"><a href="#转换分类" class="headerlink" title="转换分类"></a>转换分类</h2><ol><li>基本数据类型强制转换<br>从存储范围大的类型到存储范围小的类型</li><li>引用数据类型强制转换<br>结论：在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。  </li></ol><p>成功的例子:  </p><blockquote><p><code>Father father = new Son();</code><br><code>Son son = (Son) father;</code>  </p></blockquote><p>失败的例子:  </p><blockquote><p><code>Father father = new Father();</code><br> <code>Son son = (Son) father;</code>   </p></blockquote><p>编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Clone方法——深复制与浅复制</title>
      <link href="/clone%E6%96%B9%E6%B3%95%E2%80%94%E6%B7%B1%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6/"/>
      <url>/clone%E6%96%B9%E6%B3%95%E2%80%94%E6%B7%B1%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>在学习clone方法的时候产生的一点小思考<br><a id="more"></a><br>如果使用clone方法必须实现Cloneable方法。<br>在复制过程中存在深复制与浅复制。浅复制仅仅复制基本类型，对于引用类型则没有完全复制，仅仅是引用而已。深复制则不同，全部复制。</p><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><pre><code>public class CloneTest {    public static void main(String[] args) throws CloneNotSupportedException {    Father father = new Father(50,&quot;Father&quot;);    Father father1 = (Father) father.clone();    father1.setAge(10);    father1.setName(&quot;Father1&quot;);    System.out.println(father + &quot; &quot; +father.getAge() + &quot; &quot; + father.getName());    System.out.println(father1 + &quot; &quot; +father1.getAge() + &quot; &quot; + father1.getName());  }}</code></pre><p>输出结果是  </p><pre><code>Clone.Father@677327b6 50 FatherClone.Father@14ae5a5 10 Father1</code></pre><p>事实证明，使用clone进行的拷贝对于基本数据类型是进行新建空间复制过去的。</p><pre><code>public class Father implements Cloneable {    private String name;    private int age;    private ID id;        public Father(ID id,String name,int age){        this.id = id;        this.name = name;        this.age = age;    }        public void setId(ID id){        this.id = id;    }        public ID getId() {        return id;    }    @Override        public Object clone() throws  CloneNotSupportedException{        Father father = (Father)super.clone();        return father;        }}public class ID {    private int ID;        public void setID(int ID){        this.ID = ID;    }        public int getID(){        return ID;    }}public class CloneTest {    public static void main(String[] args) throws CloneNotSupportedException {        ID id = new ID();        id.setID(1);        Father father = new Father(id,&quot;Father&quot;,40);        Father father1 = (Father)father.clone();        System.out.println(father.getId().getID());        System.out.println(father1.getId().getID());        id.setID(2);        System.out.println(father.getId().getID());        System.out.println(father1.getId().getID());    }}</code></pre><p>输出结果为：</p><pre><code>1122</code></pre><p>可见修改一个ID，两个对象都改变了ID，所以可以发现，两个ID使用的都是同一块地址，所以修改ID才会造成两个对象同时改变地址。</p><h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>深复制的实现是通过将浅复制实现cloneable  </p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深入思考 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>Tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>Timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
