<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>感知机</title>
      <link href="/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>二分类的<strong>线性</strong>分类模型，输入为实例的特征向量，输出为实例的类别，取+1和-1二值。感知机对应于输入空间中将实例划分为正负两类的分离超平面，属于<strong>判别模型</strong>。<br>感知机的学习旨在最小化分类误差，所以引入基于误分类的误差函数，通过梯度下降法最小化误差函数求得感知机。 </p><h2 id="感知机算法学习思路："><a href="#感知机算法学习思路：" class="headerlink" title="感知机算法学习思路："></a>感知机算法学习思路：</h2><p>自己通过学习《统计学习方法》，对感知机有一些浅薄的理解，整理出了以下几个问题。通过回答以下问题可以了解感知机的具体思路。</p><ol><li>什么是感知机模型？</li><li>怎么求感知机模型(求的是什么)？</li><li>损失函数是什么(为什么要用损失函数)？</li><li>通过什么方法习得感知机模型(通过什么方法求得最小的损失函数)？</li><li>为什么一定可以习得感知机模型(算法的收敛性证明)</li><li>怎么优化这个算法(感知机的对偶形式)</li></ol><h2 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h2><p>输入空间到输出空间函数($w$ 是超平面的法向量，$b$是法向量的截距)：<br>$$ f(x) = sign(w * x + b)$$</p><h2 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h2><ul><li>定义：数据集的线性可分性:    </li></ul><p>习得感知机模型的思路：    </p><ul><li>目标：求得感知机就是求出超平面，也就是求出$w$与$x$两个变量。  </li><li>方法：为了求最合适的$w$与$x$，创造出损失函数，这样求感知机的问题就转化为损失函数最小化的问题。</li><li>问题：    <code>1. 如何确定损失函数？    2. 通过和种方法将损失函数降到最小？</code></li></ul><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>最容易想到损失函数就是误分类点的个数，但是这样的函数不是参数$w$与$b$的连续可导函数，不方便优化。<br>感知机采用的损失函数是误分类点到超平面的总距离(是参数$w$、$b$ 的可导函数)  </p><pre><code class="diff">+ 为什么是这个定义？？？</code></pre><ul><li>空间任意一点到超平面的距离：  </li><li>误分类点到超平面的距离：</li><li>误分类点到超平面的总距离：</li><li>经过简化习得损失函数：</li></ul><pre><code class="diff">+ ！！！为啥不考虑 $\frac{1}{\| w\|}$</code></pre><h3 id="损失函数最小化"><a href="#损失函数最小化" class="headerlink" title="损失函数最小化"></a>损失函数最小化</h3><p>采用 <a href="https://ahscuml.github.io/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"><code>随机梯度下降法(SGD)</code></a></p><h3 id="算法的收敛性证明"><a href="#算法的收敛性证明" class="headerlink" title="算法的收敛性证明"></a>算法的收敛性证明</h3><ul><li>定理2.1(Novikoff):<br>前提是数据集是线性可分数据集。  <ul><li>定理表明，误分类的次数$k$是有上界的，经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。  </li><li>当训练数据集线性可分时，感知机学习算法原始形式迭代是收敛的。  </li><li>感知机学习算法存在许多解，这些解既依赖于处置的选择，也依赖于迭代过程中误分类点的选择顺序。</li></ul></li></ul><hr><h2 id="感知机学习算法-摘自《统计学习方法》"><a href="#感知机学习算法-摘自《统计学习方法》" class="headerlink" title="感知机学习算法(摘自《统计学习方法》)"></a>感知机学习算法(摘自《统计学习方法》)</h2><h3 id="学习算法原始形式"><a href="#学习算法原始形式" class="headerlink" title="学习算法原始形式"></a>学习算法原始形式</h3><p><a href="https://blog.csdn.net/dcrmg/article/details/52416832" target="_blank" rel="noopener">数学知识，点积与叉积</a><br><img src="http://ww1.sinaimg.cn/large/7f349269ly1ftn31waqzcj20vm09paco.jpg" alt="学习算法原始形式"></p><ul><li>采用<strong>随机梯度下降法</strong><br>随机梯度下降算法的具体应用。<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1ftn3445t8zj20ty0imgsp.jpg" alt="感知机学习算法原始形式"></li></ul><p>感知机学习算法由于采用不同的初值或选取不同的误分类点，解可以不同。<br>当训练数据集<a href="https://en.wikipedia.org/wiki/Linear_separability" target="_blank" rel="noopener">线性可分</a>时，感知机学习算法原始形式迭代是收敛的(一定有解)</p><h3 id="感知机学习算法对偶形式"><a href="#感知机学习算法对偶形式" class="headerlink" title="感知机学习算法对偶形式"></a>感知机学习算法对偶形式</h3><p>对偶形式的目的是降低运算量：样本点的特征向量以内积的形式存在于感知机对偶形式的算法中，因此，如果事先计算好所有的内积，也就是Gram矩阵，就可以大大地加快计算速度。<br><img src="http://ww1.sinaimg.cn/large/7f349269ly1ftnalbv4cvj20mn0fa0uo.jpg" alt="感知机对偶形式内容"><br><img src="http://ww1.sinaimg.cn/large/7f349269ly1ftnajuec9lj20ob0obwfu.jpg" alt="感知机对偶形式算法"></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 梯度下降 </tag>
            
            <tag> 感知机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>梯度下降</title>
      <link href="/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
      <url>/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
      <content type="html"><![CDATA[<p>梯度下降是机器学习中非常重要的一种方法。</p><h2 id="什么是梯度"><a href="#什么是梯度" class="headerlink" title="什么是梯度"></a>什么是梯度</h2><p>标量场中某一点的梯度指向在这点标量场增长最快的方向<br>梯度的绝对值是长度为1的方向中函数最大的增加率<br>以下为引出梯度的逻辑顺序（高等数学）：</p><ul><li>导数: 一元函数变化率</li><li>偏导数: 多元函数 函数沿坐标轴方向的变化率</li><li>方向导数: 多元函数，函数沿任意方向的变化率  </li><li>梯度: 是一个向量，方向是方向导数取得最大值的方向，模等于方向导数的最大值。</li></ul><h2 id="什么是梯度下降法-Gradient-Descent"><a href="#什么是梯度下降法-Gradient-Descent" class="headerlink" title="什么是梯度下降法(Gradient Descent)"></a>什么是梯度下降法(Gradient Descent)</h2><p>明白了梯度的概念，对于梯度下降法的概念也很容易理解了。梯度是增长最快的方向，只需要向梯度相反的方向就是函数下降最快的方向(垂直方向增长率为0)，不断向梯度下降最快的方向移动可以求出局部极小值。<br><a href="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95" target="_blank" rel="noopener">梯度下降法</a>（英语：Gradient descent）是一个一阶最优化算法，通常也称为最速下降法。 要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度（或者是近似梯度）的反方向的规定步长距离点进行迭代搜索。    </p><h2 id="什么是随机梯度下降法-Stochastic-Gradient-Descent"><a href="#什么是随机梯度下降法-Stochastic-Gradient-Descent" class="headerlink" title="什么是随机梯度下降法 (Stochastic Gradient Descent)"></a>什么是随机梯度下降法 (Stochastic Gradient Descent)</h2><p>与梯度下降不同，随机梯度下降就是每次只随机选取一个样本，用这个样本来寻找下降的梯度。虽然这样子不如梯度下降精确，但是这样可以在前期更快的下降，而且结果也是在极小值附近。但是到后期可能会在极值点左右摆动。</p><h2 id="什么是批量梯度下降-Batch-Gradient-Descent"><a href="#什么是批量梯度下降-Batch-Gradient-Descent" class="headerlink" title="什么是批量梯度下降(Batch Gradient Descent)"></a>什么是批量梯度下降(Batch Gradient Descent)</h2><p>介于梯度下降与随机梯度下降之间的一种方法。梯度下降选取所有的样本，随机梯度下降只选取一个样本，批量梯度下降则选取一个批量的样本来计算梯度。</p><h2 id="随机梯度下降与梯度下降比较-随机梯度下降的优势"><a href="#随机梯度下降与梯度下降比较-随机梯度下降的优势" class="headerlink" title="随机梯度下降与梯度下降比较(随机梯度下降的优势)"></a>随机梯度下降与梯度下降比较(<a href="https://zhuanlan.zhihu.com/p/28060786" target="_blank" rel="noopener">随机梯度下降的优势</a>)</h2><ul><li>相对于非随机算法，SGD 能更有效的利用信息，特别是信息比较冗余的时候。</li><li>相对于非随机算法， SGD 在前期迭代效果卓越。</li><li>如果样本数量大，那么 SGD的Computational Complexity 依然有优势。</li></ul>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划</title>
      <link href="/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<p>动态规划的基本内容</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>动态规划算法并非适用于所有的最优化问题(还有其他算法，例如贪心算法),适用于动态规划求解的问题应具备两个基本要素:<strong>最优子结构性质</strong>和<strong>子问题重叠性质</strong>。<br>动态规划的本质是对<strong>问题状态</strong>的定义和问题<strong>状态转移方程</strong>的定义<br>动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p><ul><li><strong>子问题重叠性质</strong>：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</li><li><p><strong>无后效性</strong>:如果在某个阶段上过程的状态已知，则从此阶段以后过程的发展变化仅与此阶段的状态有关，而与过程在此阶段以前的阶段所经历过的状态无关。</p></li><li><p><strong>最优子结构性质</strong>：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。<br>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）<br>最优子结构性质,通俗地讲就是问题的最优解包含其子问题的最优解。也就是说,如果把问题的最优解分解(比如划分为两个或者多个部分,或者删除第一个或者最后一个分量),得到一个子解,那么这个子解是特定子问题的最优解。最优子结构性质隐含了问题最优解和子问题最优解之间的一种递推关系。它是动态规划的基础,保障了问题的最优解可以由子问题的最优解构造得到,即得到动态规划算法的递推方程。如果一个问题不具备该性质,则不可能用动态规划方法来求解。在分析问题的最优子结构性质时,人们一般采用反证法:首先假设由问题最优解S导出的子问题的解不是最优的,然后再推导在这个假设下可构造出比S更好的解S’,从而得到矛盾。<br>分治算法求解问题时,每次产生的子问题并不总是新问题,有些子问题重复出现,这种性质称为子问题重叠性质。<br>在动态规划算法中,对于重复出现的子问题,只是在第一次遇到时执行求解过程,然后把求解结果保存在一个表格(可能是高维表格)中,再遇到这个子问题时,直接从表格中引用答案,从而避免重复计算,达到提高效率的目标。<br>需要提醒的是,子问题重叠性质不是动态规划适用的必要条件,但是如果该性质不满足时,动态规划方法与其他方法相比就不具备优势。</p></li></ul><hr><h3 id="另一种理解"><a href="#另一种理解" class="headerlink" title="另一种理解"></a>另一种理解</h3><blockquote><ul><li>每个阶段只有一个状态-&gt;<strong>递推</strong>；  </li><li>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;<strong>贪心</strong>；  </li><li>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;<strong>搜索</strong>；  </li><li>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;<strong>动态规划</strong>。   </li></ul></blockquote><p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做<strong>最优子结构</strong>；<br>而不管之前这个状态是如何得到的这个性质叫做<strong>无后效性</strong>。</p><hr><h2 id="动态规划计算方法"><a href="#动态规划计算方法" class="headerlink" title="动态规划计算方法"></a>动态规划计算方法</h2><ul><li>递归  </li><li>自顶向下的备忘录法（不一定最优）<br>从上开始，将已经计算过的内容存储起来</li><li>自底向上<br>从最初的，最底层的内容开始，从小计算到大</li></ul><p>动态规划算法设计步骤<br>动态规划算法适合用于求解最优化问题,通常可按下列步骤来设计动态规划算法:</p><blockquote><ol><li>分析最优子结构性质;</li><li>确定状态表示和状态递推方程,递归地定义最优值;</li><li>确定状态转移顺序,以自底向上的方式计算出最优值;</li><li>根据计算最优值时得到的信息,构造最优解。</li></ol></blockquote><p>第(1)步是基础,也是关键。在分析最优子结构性质时,子解分解和子解对应的子问题描述是关键。本书将介绍两种子解分解方法:基于划分的方法和基于减一的方法。在第一种方法中,问题的最优解依据问题性质划分成两个或者多个子解,但是其划分位置无法事先确定;在第二种方法中,问题的最优解依据问题性质缩减规模,比如减去最优解的第一个分量,或者最后一个分量,得到规模少1个单位的子解。得到子解后,分析和描述该子解对应的子问题,如果能证明该子解是对应子问题的最优解,则该问题满足最优子结构性质,转入第(2)步;否则,该问题不能用动态规划求解。</p><p>第(2)步是动态规划算法的核心,它是最优解的规划过程。状态表示本质上就是子问题的表示,形如f(x1,…,xk),其中x1,…,xk 是描述子问题的参数列表,每一个参数都需要定义其取值范围;f(·)的值域则体现问题的求解目标,一般地,f(·)直接定义为待求解问题的目标值。需要注意的是,对于有些问题来说,f(·)如果直接定义为原问题目标值,可能最优子结构性质不成立。此时,f(·)往往定义为某个中间目标值,比如最大上升子序列问题。在算法实现时,状态f(x1,…,xk)一般用一个k 维的表格存储,动态规划过程就是表格操作过程。</p><p>第(3)步体现了动态规划算法的执行过程。通俗地讲,动态规划是一个由易至难的求解过程:先求解最简单的子问题的解,然后利用简单子问题的解构造复杂一些的子问题的解,直至求解原问题的解。</p><p>第(4)步是可选步骤,只有问题要求构造最优解时才需要。</p><hr><h3 id="贪心算法与动态规划"><a href="#贪心算法与动态规划" class="headerlink" title="贪心算法与动态规划"></a><a href="https://blog.csdn.net/jarvischu/article/details/6056387" target="_blank" rel="noopener">贪心算法与动态规划</a></h3><p><del>自己的理解：贪心就是一直选最优最终就是最优的。动态规划是每个小问题做最优，不是从最初选最优就是最优的。</del></p><p>求最优解的问题，从根本上说是一种对解空间的遍历。最直接的暴力分析容易得到，最优解的解空间通常都是以指数阶增长，因此暴力穷举都是不可行的。<br>最优解问题大部分都可以拆分成一个个的子问题，把解空间的遍历视作对子问题树的遍历，则以某种形式对树整个的遍历一遍就可以求出最优解，如上面的分析，这是不可行的。<br>贪心和动态规划本质上是对子问题树的一种修剪。两种算法要求问题都具有的一个性质就是“子问题最优性”。即，组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的。如果以自顶向下的方向看问题树（原问题作根），则，我们每次只需要向下遍历代表最优解的子树就可以保证会得到整体的最优解。形象一点说，可以简单的用一个值（最优值）代表整个子树，而不用去求出这个子树所可能代表的所有值。<br>动态规划方法代表了这一类问题的一般解法。我们自底向上（从叶子向根）构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，其它的值舍弃。动态规划的代价就取决于可选择的数目（树的叉数）和子问题的的数目（树的节点数，或者是树的高度？）。<br>贪心算法是动态规划方法的一个特例。贪心特在，可以证明，每一个子树的根的值不取决于下面叶子的值，而只取决于当前问题的状况。换句话说，不需要知道一个节点所有子树的情况，就可以求出这个节点的值。通常这个值都是对于当前的问题情况下，显而易见的“最优”情况。因此用“贪心”来描述这个算法的本质。由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。这样，与动态规划相比，它的代价只取决于子问题的数目，而选择数目总为1。</p><hr><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a><a href="http://www.cppblog.com/menjitianya/archive/2015/10/23/212084.html" target="_blank" rel="noopener">习题</a></h2><p><strong>线性模型:指状态的排布是呈线性的</strong></p><h3 id="习题1-小朋友过桥问题"><a href="#习题1-小朋友过桥问题" class="headerlink" title="习题1 小朋友过桥问题"></a>习题1 小朋友过桥问题</h3><p>在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。</p><blockquote><p>我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以opt[i] = opt[i-1] + a[1] + a[i] (让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)<br>如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以<br>opt[i] = opt[i-2] + a[1] + a[i] + 2*a[2] (让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题)<br>所以 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2*a[2] }</p></blockquote><h3 id="习题2-最长单调子序列问题"><a href="#习题2-最长单调子序列问题" class="headerlink" title="习题2 最长单调子序列问题"></a>习题2 最长单调子序列问题</h3><p>给定一个长度为n(1 &lt;= n &lt;= 1000)的整数序列a[i]，求它的一个子序列(子序列即在原序列任意位置删除0或多个元素后的序列)，满足如下条件：<br>      1、该序列单调递增；<br>      2、在所有满足条件1的序列中长度是最长的；</p><blockquote></blockquote><h3 id="习题2-回文串问题（区间模型）"><a href="#习题2-回文串问题（区间模型）" class="headerlink" title="习题2 回文串问题（区间模型）"></a>习题2 回文串问题（区间模型）</h3><p>给定一个长度为n（n &lt;= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。</p><h3 id="习题3-背包问题（背包模型）"><a href="#习题3-背包问题（背包模型）" class="headerlink" title="习题3 背包问题（背包模型）"></a>习题3 背包问题（背包模型）</h3><p>有N种物品（每种物品1件）和一个容量为V的背包。放入第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。f[i][v]表示前i种物品恰好放入一个容量为v的背包可以获得的最大价值。决策为第i个物品在前i-1个物品放置完毕后，是选择放还是不放，状态转移方程为：</p>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法</title>
      <link href="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>基于网络课程和《数据结构与算法分析——Java语言描述》，基本排序算法的讲解，以及Java代码实现。<br><a id="more"></a><br>O(n²) 时间复杂度<br>虽然时间复杂度相对较高，但是同样也有好处</p><ul><li>编码相对简单</li><li>在某些情况下，这些算法反而更有效</li><li>可以从简单的方法中衍生出复杂的算法</li><li>作为子过程，经过修改变为复杂的算法</li></ul><p>重要的思想：<br><strong>逆序数</strong>：排序的过程就是消除逆序数的过程，所以逆序数的个数影响排序的性能(也可以从这个角度来思考排序的性能)  </p><ul><li>N个互异数的数组的平均逆序数是 $ N(N-1)/4 $(数对的一半)  </li><li>通过交换相邻元素进行排序的任何算法平均都需要 $ Ω(N^2) $  </li><li>对于归并排序，归并过程中，可以一次消除多个逆序数，提高算法效率。</li></ul><h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序 Selection Sort"></a>选择排序 Selection Sort</h3><p>从未排序的数组中逐一选择最小的元素进行排序<br><strong>KEY：寻找数组中最小的元素</strong><br>大约需要 $\frac{N^2}{2}$次比较和N次交换<br>可以考虑对算法进行升级，不仅仅对整型进行排序，对浮点型甚至对对象进行排序（采用Comparable接口，然后通过compareto进行比较）<br><strong>特点：</strong></p><ul><li>运行时间和输入无关(这样对于最开始就基本有序的数组就没有优势了)  </li><li>数据移动最少 </li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><pre><code class="Java">public class SelectionSort{    public static void SelectionSort(Comparable[] arr) {        int n = arr.length;        for (int i = 0; i &lt; n; i++) {            int minindex = i;            //注意是从i+1开始的            for (int j = i + 1; j &lt; n; j++) {                if(arr[j].compareTo(arr[minindxe]) &lt; 0){                    minindex = j;                }            }            swap(arr,minindex,i);        }    }    public static void swap(Object[] arr, int i, int j){        Object e = arr[i];        arr[i] = arr[j];        arr[j] = e;    }}</code></pre><h4 id="选择排序优化"><a href="#选择排序优化" class="headerlink" title="选择排序优化"></a>选择排序优化</h4><p>优化前，一次遍历仅仅可以找到最小的排好序，优化后，一次遍历可以找到最小的以及最大的两个元素排好序</p><pre><code class="java">public class SelectionSort {    public static void selectionSort(Comparable[] arr) {        int n = arr.length;        int left = 0, right = n - 1;        while(left &lt; right){            int minindex = left, maxindex = right;            if(arr[minindex].compareTo(arr[maxindex]) &gt; 0)                swap(arr, minindex, maxindex);                //注意i的范围            for(int i = left + 1; i &lt; right; i++) {                if (arr[i].compareTo(arr[minindex]) &lt; 0) {                    minindex = i;                }                if (arr[i].compareTo(arr[maxindex]) &gt; 0) {                    maxindex = i;                }            }            swap(arr, left, minindex);            swap(arr, right, maxindex);            left++;            right--;        }    }}</code></pre><h3 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h3><p>插入排序由N-1趟排序组成。对于p到N-1趟，插入排序保证从位置0到位置p上的元素为已排状态。<br><strong>KEY:比前面一个小就进行交换，否则结束这一次插入(比选择排序优秀的地方，可以提前结束)</strong>  </p><ul><li>平均情况下，插入排序需要$\frac{N^2}{4}$次比较与$\frac{N^2}{4}$次交换  </li><li>逆序数思考维度，每一次交换都是在减少一个逆序数，那么就需要逆序数次交换。</li><li><p>对插入排序进行优化：之前的插入排序每一次插入都要进行很多次交换，然而每次交换都是三次赋值的时间，所以很浪费时间，这样可以牺牲一个时间复杂度，将要插入的元素跟之前的元素进行比较，但是先不交换，等到找到要交换的元素，再进行一次交换，这样每一次插入都只进行一次交换。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>插入排序为$O(n^2)$,如果输入数组时反序的时候，复杂度为$\Theta(N^2)$,如果输入已经预先排序，那么复杂度为$O(N^2)$。正因如此<strong>如果输入几乎被排序，那么插入排序将运行的更快。</strong></p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><pre><code class="java">public class InsertionSort{  public static void insertionSort(Comparable arr) {      int n = arr.length;      for(int i = 0; i &lt; n; i++) {          // 寻找元素arr[i]合适的插入位置          // 写法1          // for( int j = i ; j &gt; 0 ; j -- )          //    if( arr[j].compareTo( arr[j-1] ) &lt; 0 )          //        swap( arr, j , j-1 );          //    else          //        break;          // 写法2//            for( int j = i; j &gt; 0 &amp;&amp; arr[j].compareTo(arr[j-1]) &lt; 0 ; j--)//                swap(arr, j, j-1);          // 写法3          // 改进的插入算法，利用赋值替代交换，减少时间消耗          Comparable e = arr[i];          int j = i;          for( ; j &gt; 0 &amp;&amp; arr[j-1].compareTo(e) &gt; 0 ; j--)              arr[j] = arr[j-1];          arr[j] = e;      }  }  public static void swap(Object[] arr, int i, int j){      Object e = arr[i];      arr[i] = arr[j];      arr[j] = e;  }}</code></pre></li></ul><h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 Bubble Sort"></a>冒泡排序 Bubble Sort</h3><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。  </p><pre><code class="java">public class ShellSort {    private ShellSort() {    }    /**     * 希尔排序算法     */    public static void sort(Comparable[] arr) {        int n = arr.length;        int h = 1;        while (h &lt; n / 3) {            h = 3 * h + 1;        }        while (h &gt;= 1) {            // 排序是从h到n            for (int i = h; i &lt; n; i++) {                Comparable e = arr[i];                int j = i;                for (; j &gt;= h &amp;&amp; e.compareTo(arr[j - h]) &lt; 0; j -= h) {                    arr[j] = arr[j - h];                }                arr[j] = e;            }            h /= 3;        }    }    /**     * 测试用例     */    public static void main(String[] args) {        int N = 1000000;        Integer[] arr = SortTestHelper.generateRandomArray(N, 0, 100000);        SortTestHelper.testSort(&quot;sort.ShellSort&quot;, arr);    }}</code></pre><h3 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序 Shell Sort"></a>希尔排序 Shell Sort</h3><ul><li>希尔排序通过比较一定间隔的元素来工作，，各趟比较所用的距离随着算法的进行而减小，知道只比较相邻元素的最后一趟排序为止。  </li><li>$h_k$排序的一般做法是，对于$h_k$，$h_{k+1}$，···$N-1$中的每一个位置<em>i</em>,把其上的元素放到<em>i</em>，$i-h_k$,$i-2h_k$,···中的正确位置上。<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4></li><li>希尔排序的一个重要性质就是一个$h_k$排序的文件保持它的$h_k$排序性(我的理解就是，经过$h_k$排序后，逆序对不会再增加)  </li><li>使用希尔增量时希尔排序的最坏情形运行时间为$\Theta(N^2)$<pre><code class="java">public class ShellSort {  privata ShellSort(){}  public static void shellSort(Comparable[] arr){      for(int gap = arr.length/2; gap &lt; arr.length; gap /= 2) {          for(int i = gap; i &lt; arr.length; i++) {              // 使用插入排序              Comparable[] temp = arr[i];              int j = i;              for(; j &gt;= gap &amp;&amp; temp.compareTo(arr[j - gap]) &lt;0; j-=gap){                  a[j] = a[j - gap];              }              a[j] = temp;          }      }  }}</code></pre></li></ul><hr><p>O(nlgn)复杂度的排序算法<br>分治算法的思想(分而治之)  </p><blockquote><p>归并排序 重点在合(如何合)<br>快速排序 重点在分(如何分)  </p></blockquote><h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h3><p><strong>KEY：将两个有序的数组合并为一个有序的数组</strong><br>牺牲了存储空间，获得了时间上的减少。<br>首先进行分层，然后对每一层使用归并排序<br><strong>归并排序的逻辑</strong>  递归的思想，这也是递归的一个很好的例子。对于递归的效率分析也是一个很好的技巧(叠缩求和与带入法)<br><strong>优化：</strong></p><ul><li>对近乎有序的数组进行优化要判断要不要进行归并</li><li>由于对于小数据量的元素使用插入排序更加迅速， 所及可以考虑分层进行到一部分的时候改用插入排序(一部分是怎么确定的？)</li></ul><p>优化后的归并排序</p><pre><code class="java">public class MergeSort {    private MergeSort() {    }    /**     * 递归使用归并排序，对arr[l...r]的范围进行排序     */    private static void sort(Comparable[] arr, int l, int r) {        /*if(l&gt;=r){            return;        }*/        // 优化2：在归并到一定程度的时候使用插入排序        int size = 15;        if (r - l &lt;= size) {            insertionSort(arr, l, r);        }        // int mid = (r - l) / 2 + l;        int mid = (l + r) / 2;        sort(arr, l, mid);        sort(arr, mid + 1, r);        // 优化1：如果已经有序就不进行归并了。        if (arr[mid].compareTo(arr[mid + 1]) &gt; 0) {            merge(arr, l, mid, r);        }    }    /**     * 将arr[l...mid]和arr[mid+1...r]两部分进行归并     */    private static void merge(Comparable[] arr, int l, int mid, int r) {        //拷贝一个数组赋值用(牺牲空间复杂度，降低时间复杂度)        //注意还有个+1        Comparable[] aux = Arrays.copyOfRange(arr, l, r + 1);                // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1        int i = l, j = mid + 1;        for (int k = l; k &lt;= r; k++) {            // 如果左半部分元素已经全部处理完毕            if (i &gt; mid) {                // j - l很关键                arr[k] = aux[j - l];                j++;                // 如果右半部分元素已经全部处理完毕            } else if (j &gt; r) {                arr[k] = aux[i - l];                i++;                // 左半部分所指元素 &lt; 右半部分所指元素            } else if (aux[i - l].compareTo(aux[j - l]) &lt; 0) {                arr[k] = aux[i - l];                i++;                // 左半部分所指元素 &gt;= 右半部分所指元素            } else {                arr[k] = arr[j - l];                j++;            }        }    }    private static void insertionSort(Comparable[] arr, int l, int r) {        for (int i = l + 1; i &lt;= r; i++) {            int j = i;            Comparable e = arr[j];            for (; j &gt; l; j--) {                if (e.compareTo(arr[j - 1]) &lt; 0) {                    arr[j] = arr[j - 1];                } else {                    break;                }            }            arr[j] = e;        }    }}</code></pre><h4 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h4><p>不使用递归，只用迭代性能相对来说要差一点点<br>并没有使用到数组的特性(通过下标寻找元素)，所以对于链表很适用。<br>对于数组要思考到越界的问题  </p><pre><code class="java">public class MergeSortBUAdvanced{    /**     * 自底向上归并排序优化     * 1、在size小的时候采用插入排序     * 2、如果归并之前已经有序，则不进行归并     */    public static void sort(Comparable[] arr) {        int n = arr.length;        // 设置size，低于这个size使用插入排序        int size = 16;        // 优化1： 小数组使用插入排序更优化        for (int i = 0; i &lt; n; i += size) {            insertionSort(arr, i, Math.min(i + size - 1, n - 1));        }        for (; size &lt; n; size += size) {            for (int i = 0; i + size  &lt; n; i += size + size) {                // 优化2： 如果之前已经有序，则不进行归并                if (arr[i + size - 1].compareTo(arr[i + size]) &gt; 0) {                    merge(arr, i, i + size - 1, Math.min(i + size + size - 1, n - 1));                }            }        }    }    private static void merge(Comparable[] arr, int l, int mid, int r) {        Comparable[] aux = Arrays.copyOfRange(arr, l, r + 1);        int i = l, j = mid + 1;        for (int k = l; k &lt;= r; k++) {            if (i &gt; mid) {                arr[k] = aux[j - l];                j++;            } else if (j &gt; r) {                arr[k] = aux[i - l];                i++;            } else if (aux[i - l].compareTo(aux[j - l]) &lt; 0) {                arr[k] = aux[i - l];                i++;            } else {                arr[k] = aux[j - l];                j++;            }        }    }    // 优化中使用的插入排序    private static void insertionSort(Comparable[] arr, int l, int r) {        for (int i = l; i &lt;= r; i++) {            Comparable e = arr[i];            int j = i;            for (; j &gt; l; j--) {                if (e.compareTo(arr[j - 1]) &lt; 0) {                    arr[j] = arr[j - 1];                } else {                    break;                }            }            arr[j] = e;        }    }}</code></pre><h4 id="问题：求逆序数个数"><a href="#问题：求逆序数个数" class="headerlink" title="问题：求逆序数个数"></a>问题：求逆序数个数</h4><p>对递归的理解很关键，通过运用归并排序的方法，使得求逆序数的复杂度变为 $O(nlogn$</p><pre><code class="java">public class InversionCount{    /**     * 递归排序(用作分割)     */    public static long sort(Comparable[] arr, int l, int r) {        if (l &gt;= r) {            return 0L;        }        int mid = l + (r - l) / 2;        // 求出 arr[l...mid] 范围的逆序数        long countl = sort(arr, l, mid);        // 求出 arr[mid+1...r] 范围的逆序数        long countr = sort(arr, mid + 1, r);        // 两个count分别是上一个merge的结果，这就相当于将所有的merge结果相加        return countl + countr + merge(arr, l, mid, r);    }    /**     * 合并操作,就是一个排序的过程     */    private static long merge(Comparable[] arr, int l, int mid, int r) {        // 逆序数对个数初始化        long count = 0L;        // merge操作        Comparable[] aux = Arrays.copyOfRange(arr, l, r + 1);        int i = l, j = mid + 1;        for (int k = l; k &lt;= r; k++) {  // 如果左半部分元素已经全部处理完毕            if (i &gt; mid) {                arr[k] = aux[j - l];                j++;            } else if (j &gt; r) {  // 如果右半部分元素已经全部处理完毕                arr[k] = aux[i - l];                i++;            } else if (aux[j - l].compareTo(aux[i - l]) &gt;= 0) {  // 左半部分所指元素 &lt;= 右半部分所指元素                arr[k] = aux[i - l];                i++;            } else { // 右半部分所指元素 &lt; 左半部分所指元素                arr[k] = aux[j - l];                j++;                // 此时, 因为右半部分j所指的元素小                // 这个元素和左半部分的所有未处理的元素都构成了逆序数对(不包括右边的是因为右边的在上一次迭代的时候已经计算过了)                // 左半部分此时未处理的元素个数为 mid - i + 1(注意i的意思，i是将要处理的元素)                count = count + (long) (mid - i + 1);            }        }        return count;    }}</code></pre><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 Quick Sort"></a>快速排序 Quick Sort</h3><p><strong>key:如何将数组分为大小两个(Partition)</strong><br>递归思想，分别使用快速排序<br>围绕着枢纽元进行大小分离，不进行排序，只区分大小  </p><h4 id="简单快速排序-注意数组的边界"><a href="#简单快速排序-注意数组的边界" class="headerlink" title="简单快速排序(注意数组的边界)"></a>简单快速排序(注意数组的边界)</h4><blockquote><ol><li>首先确定元素$v$</li><li>遍历数组(j是$&lt;v$的尾部，i是$&gt;v$的尾部,e是遍历的元素)<br><img src="算法与数据结构/QuickSort/QuickSort1.png" alt="快速排序结构1"></li><li>遍历一遍的数组结构<br><img src="算法与数据结构/QuickSort/QuickSort2.png" alt="快速排序结构2">)</li><li>最终的结构，j是选定元素的下标，左边是小于$v$的元素，右面是大于$v$的元素<br><img src="算法与数据结构/QuickSort/Quicksort3.png" alt="快速排序结构3"></li></ol></blockquote><pre><code class="java">public class QuickSort{    public static void quickSort(Comparable[] arr, int l, int r){        // 递归的基准情况        if (l &gt;= r) {            return;        }        // partion操作，移动元素，找到中值的位置        Comparable v = arr[l];        int j = l;        for (int i = l + 1; i &lt;= r; i++) {            if (arr[i].compareTo(v) &lt; 0) {                j++;                swap(arr, j, i);            } else {                i++;            }        }        swap(arr, l, j);        j--;        // 进行递归        sort(arr, l, j);        sort(arr, j + 2, r);    }    // 交换函数    private static void swap(Comparable[] arr, int i, int j) {        Comparable temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}</code></pre><h4 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h4><p>重点关注列表中下标的位置，根据整个流程来编写程序，同时在分界点，根据下标来区分。</p><ol><li>底层可以采用插入排序的算法进行优化</li><li>针对 <strong>近乎有序</strong> 数组的优化。和归并排序比较，都是利用递归，同样将数组一分为二，但是归并左右两部分是平衡的而快速排序却不是(根据元素的选择)。 不再采用第一个元素为中间值，采用随机选取元素作为中间值。</li><li>针对有 <strong>重复元素</strong> 的数组进行的优化。由于在对数组进行分类的时候，与中间值相等的元素并没有进行考虑，所以仍旧被分到了两侧，这样下一次排序仍然要对这些元素进行比较，导致速度很慢。 可以考虑在分类的时候，将大的元素从后往前放置，小的元素从前往后放置，将与中间值相等的元素分散到两侧，这样对于有大量的相同元素的数组可以避免一边数据量很大造成不平衡。  <blockquote><ul><li>新的算法思想<span id="QuickSort2Ways">(QuickSort2Ways)</span></li></ul><ol><li>改变放置的方式<br><img src="算法与数据结构/QuickSort/QuickSortAdvanced1.png" alt="QuickSortAdvanced"></li><li>继续从i开始向后遍历元素，直到找到元素$&gt;=v$。<br><img src="算法与数据结构/QuickSort/QuickSortAdvanced2.png" alt="QuickSortAdvanced"></li><li>继续从j开始向前遍历元素，直到找到元素$&lt;=v$。<br><img src="算法与数据结构/QuickSort/QuickSortAdvanced3.png" alt="QuickSortAdvanced"></li><li>然后交换i的元素和j的元素<br><img src="算法与数据结构/QuickSort/QuickSortAdvanced4.png" alt="QuickSortAdvanced"></li><li>继续遍历，直到i=j遍历完成</li></ol></blockquote></li></ol><pre><code class="java">public class QuickSort2Ways {   public static void QuickSort2Ways(Comparable[] arr, int l, int r) {        // 优化：小数组采用插入排序, 递归的基准情况        int size = 16;        if (r - l &lt;= size - 1) {            insertionSort(arr, l, r);            return;        }        // 优化：随机选择中间值，避免过多相同元素的情况        swap(arr, l, (int) Math.random() * (r - l + 1) + l);        // 优化：两路排序        Comparable v = arr[l];        int i = l + 1, j = r;        while (true) {            // 为什么是 &lt; 不是 &lt;= 的思考(http://coding.imooc.com/learn/questiondetail/4920.html)            while (i &lt;= r &amp;&amp; arr[i].compareTo(v) &lt; 0) {                i++;            }            while (j &gt;= l + 1 &amp;&amp; arr[j].compareTo(v) &gt; 0) {                j--;            }            // 跳出循环            if (i &gt; j) {                break;            }            swap(arr, i, j);            i++;            j--;        }        swap(arr, l, j);        // 递归调用        sort(arr, l, j - 1);        sort(arr, j + 1, r);    }    private static void swap(Comparable[] arr, int i, int j) {        Comparable temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }    private static void insertionSort(Comparable[] arr, int l, int r) {        for (int i = l; i &lt; r; i++) {            Comparable e = arr[i];            int j = i;            for (; j &gt; l; j--) {                if (arr[j - 1].compareTo(e) &gt; 0) {                    arr[j] = arr[j - 1];                } else {                    break;                }            }            arr[j] = e;        }    }}</code></pre><ol start="4"><li>在<a href="#QuickSort2Ways">QuickSort2Ways</a>的基础之上对于选定元素相等的元素也进行分类，产生QuickSort3Ways.<blockquote><ul><li>终极算法QuickSort3Ways</li></ul><ol><li>开始的状态，同时维护3路元素，分别是$&gt;v$、$&lt;v$、$=v$。初始阶段如下图，注意边界的值！<br><img src="算法与数据结构/Quicksort/QuickSort3Ways1.png" alt="QuickSort3Ways"></li><li>如果元素$e$与元素$v$相等，则将i向后移动一位<br><img src="算法与数据结构/Quicksort/QuickSort3Ways2.png" alt="QuickSort3Ways"></li><li>如果元素$e$比元素$v$小，则将$e$与 =$v$ 的元素块第一个元素(lt+1)交换,i向后移动一位<br><img src="算法与数据结构/Quicksort/QuickSort3Ways3.png" alt="QuickSort3Ways"></li><li>如果元素$e$比元素$v$大，则将$e$与 &gt;$v$ 的元素块第一个元素(gt-1)交换,i向后移动一位<br><img src="算法与数据结构/Quicksort/QuickSort3Ways4.png" alt="QuickSort3Ways">    </li><li>最终的结果就是 i 与 gt 相等，遍历结束,最终还要讲lt位置的元素与第一个元素交换位置，得到最终的数组(如果不打算维护lt这个元素，要注意数组的边界位置)<br><img src="算法与数据结构/Quicksort/QuickSort3Ways5.png" alt="QuickSort3Ways"><br><img src="算法与数据结构/Quicksort/QuickSort3Ways6.png" alt="QuickSort3Ways"></li></ol></blockquote></li></ol><pre><code class="java">public class QuickSort3Ways {    /**     * 3路快速排序算法     */    private static void QuickSort3Ways(Comparable[] arr, int l, int r) {        // 优化1：在小分组的时候使用插入排序        int size = 16;        if (r - l &lt;= size - 1) {            insertionSort(arr, l, r);            return;        }        // 优化2：随机选取元素的中间值，避免大量重复元素        swap(arr, l, (int) Math.random() * (r - l + 1) + l);        Comparable v = arr[l];        // gt从r+1开始        int lt = l, gt = r + 1, i = l + 1;        while (i &lt; gt) {            if(v.compareTo(arr[i]) &gt; 0) {                lt++;                swap(arr,i,lt);                i++;            } else if(v.compareTo(arr[i]) &lt; 0) {                // 交换了一个没有判断过的元素到i，所以i不用+1！                gt--;                swap(arr,i,gt);            } else {                // 两个元素相等的情况，不用进行交换                i++;            }        }        // 将第一个元素交换到=v的位置        swap(arr,l,lt);        lt--;        // 递归调用        sort(arr,l,lt);        sort(arr,gt,r);    }    /**     * 插入排序算法     */    public static void insertionSort(Comparable[] arr, int l, int r) {        for (int i = 1; i &lt; r - l + 1; i++) {            Comparable e = arr[i];            int j = i;            for (; j &gt; 0; j--) {                if (e.compareTo(arr[j - 1]) &lt; 0) {                    arr[j] = arr[j - 1];                } else {                    break;                }            }            arr[j] = e;        }    }    /**     * 交换函数     */    private static void swap(Comparable[] arr, int i, int j) {        Comparable temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}</code></pre><h4 id="问题：取出数组中第n大的元素"><a href="#问题：取出数组中第n大的元素" class="headerlink" title="问题：取出数组中第n大的元素"></a>问题：取出数组中第n大的元素</h4><p>如果利用先排序再找到第n个最大值，那么这个算法的复杂度为$O(nlogn)$,但是利用快速排序的思想可以很好的解决这个问题，使得复杂度变为$O(n)$</p><pre><code class="java">public static Comparable selection(Comparable[] arr, int k) {        int n = arr.length;        // 注意这里是k - 1，因为下标还包括0        return selection(arr, 0, n - 1, k - 1);}private static Comparable selection(Comparable[] arr, int l, int r, int k) {        swap(arr, l, (int) Math.random() * (r - l + 1) + l);        Comparable v = arr[l];        int j = l;        for (int i = l + 1; i &lt;= r; i++) {            if (arr[i].compareTo(v) &lt; 0) {                j++;                swap(arr, i, j);            }        }        swap(arr, l, j);        // 避免函数越界        if (l == r) {            return arr[l];        }        if (j  &lt; k) {            return selection(arr, j + 1, r, k);        } else if (j &gt; k) {            return selection(arr,l,j - 1,k);        } else {            return arr[j];        }    }    /**     * 交换函数     */    private static void swap(Comparable[] arr, int i, int j) {        Comparable temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }</code></pre><h3 id="堆排序-HeapSort"><a href="#堆排序-HeapSort" class="headerlink" title="堆排序 HeapSort"></a>堆排序 HeapSort</h3><p>重点在于堆这种数据结构<br>队列：<br>普通队列：按照时间顺序，先进先出，后进后出<br>优先队列：出队顺序和入队顺序和时间无关，和优先级有关</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><ol><li>N个互异数的数组的平均逆序数是$\frac{N(N-1)}{4}$</li><li>通过交换相邻元素进行排序的任何算法平均都需要$\Omega(N^2)$   <strong>一个排序算法通过删除逆序得以向前进行，而为了有效地进行，他必须使每次交换删除不止一个逆序</strong></li><li></li></ol>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写博客的原因</title>
      <link href="/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
      <url>/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>　　写博客这个事情我已经想了很久了，记得刚上大学的时候我就想着要写自己的博客，最开始还是想记录自己的生活，写一写随笔，因为我受高中老师的影响 ，平时也会写一写随笔的，但是由于自己不太想把自己的生活和自己的想法暴露给别人，所以自己一直没有写博客，再到后来，自己开始学习编程的知识，学习一些自己感兴趣的内容，写博客的想法又一次涌上心头，这一次不是分享自己的生活，这一次我想分享自己的学习成果。虽然说是成果，其实吧，更加像是自己对自己一种激励，或者说是自己对自己的一种监督。有了一个地方来记录自己的学习过程，并且可以被其他人看到，这对于自己来说是一个很好的鼓励，鼓励自己写一写东西。我还是一个很在意别人看法的人，所以，我可能会想着我自己有的博客，我一定要维护好，毕竟别人还会看见。让其他人觉得我很厉害。还有这也是我自己的一份记录。以前学习，我会画在书上，我会写在纸上，写上我对问题的思考，写上我的总结，但是最终会找不见，但是这次不一样了，有了自己的一块地方，我就可以把我的内容传到我自己的GitHub上，不仅仅别人可<br>以监督我写的内容，可以和别人进行讨论，同时，我自己还可以对自己学过的知识进行总结，进行记录。毕竟学过不一定会，总结，重复，才会让自己更强。督促我写这个博客还有另外一个因素，那就是我觉得很酷。我对一切很酷的东西都很感兴趣，像高中沉迷Lumia920，当时把照片贴在床板上，哈哈，督促我努力学习。博客也让我感觉很酷，普通的博客并不是，酷同时也有美的意思，就是我很喜欢的那种美，看到美的东西总让人很兴奋。这个博客还是自己搭建的，也让自己很有成就感。<br>　　当然这不是最终目标，我最终的目标是自己完全亲手搭建一个网站，拥有自己的域名，自己来维护，创造自己觉得美的东西，这让自己感觉很有动力。当然这需要很多的知识，虽然现在我还不具有这些知识，但是我会不断学习的，不断进步，让自己变得更强。<br>　　我始终喜欢那些很厉害的人。</p>]]></content>
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MarkDown使用指南</title>
      <link href="/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8markdown/"/>
      <url>/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8markdown/</url>
      <content type="html"><![CDATA[<p>我与markdown的渊源。</p><h2 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h2><p>　　主要还是因为Word不太好用，例如需要调整字体的间距，总觉得Word字体的间距太大了，不适合操作，而且其他方面编辑好以后如果需要加载到网页上，还涉及到格式转换的问题因此采用了markdown来书写，一个是书写文字非常方便，其次就是上传到自己的博客上也很方便，不涉及文字格式的从转换。</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>　　<del>我在Windows上使用的是<code>MarkDownPad</code>这款软件，其他软件我也没有使用过，首先这款软件很多人推荐，其次这款软件使用起来也很方便，很简洁。其次在很多地方都可以使用MarkDown，例如IDEA编译器也可以。</del><br>　　最近我开始使用vsCode来进行写作，不得不说真的是好用，颜色方面很有优势，看起来很舒服，还有各种插件，渲染完成的也很好，推荐。<br>　　看起来markdow使用比较繁琐，毕竟是一个新鲜的事物，我在第一次尝试的时候感觉很麻烦。但是当你真正使用起来，真正掏出30分钟来研究一下的话，还是很好上手的毕竟这仅仅是一个文本编辑器，最终还是要用来写字。  </p><h2 id="语法简述"><a href="#语法简述" class="headerlink" title="语法简述"></a>语法简述</h2><p>本文主要参考这份语法做出的简单整理<a href="http://xianbai.me/learn-md/article/extension/table.html" target="_blank" rel="noopener">MarkDown中文使用文档</a>  </p><ul><li><strong>标题</strong><br>使用<code>#</code> 来标识<br><code>#h1级标题</code><br><code>##h2级标题</code><br><code>###h3级标题</code><br><code>####h4级标题</code><br><code>#####h5级标题</code><br><code>######h6级标题</code></li><li><p><strong>列表</strong>（注意符号和文本之间增加一个空格）  </p><blockquote><ul><li>有序列表<br>使用<code>1.</code></li><li>无序列表<br>使用<code>*</code></li></ul></blockquote></li><li><p><strong>图片</strong><br><code>![链接名](链接)</code> 小括号中存放链接<br>note：<br>关于插入图片，由于markdown使用链接，所以我通常会使用图床来上传图片生成链接，推荐使用<code>新浪微博图床</code> 有专门的Chrome插件，非常方便。</p></li><li><strong>超链接</strong><br><code>[链接名](链接)</code> 小括号中存放链接</li><li><p><strong>代码</strong><br>使用 <code>`</code>包围代码，同时还可以利用名称来使代码高亮   </p><blockquote><p>```java<br>``` </p></blockquote></li><li><p><strong>引用</strong><br>在文本前加入 <code>&gt;</code> </p></li><li><strong>换行</strong><br>空格 + 空格 + 回车</li><li><strong>分割线</strong>  三个以上的短线<br>使用 <code>***</code>或者 <code>---</code>  </li><li><p><strong>删除线</strong><br>利用<code>~~删除的内容~~</code>设置删除线</p></li><li><p><strong>强调</strong><br><code>利用 *内容* 来进行斜体展示</code><br><code>利用 **内容** 来进行粗体展示</code></p></li><li><p><strong>表格</strong></p><blockquote><p> name | age<br> —　  | —<br> a　　| 10  </p></blockquote></li></ul><p>GitHub不支持表格…除非使用HTML语句</p><ul><li><strong>事项列表</strong>  <blockquote><p>- [ ] eat<br>- [x] eat<br>　　- [ ] eat</p></blockquote></li></ul><p>效果：  </p><blockquote><ul><li style="list-style: none"><input type="checkbox"> eat</li><li style="list-style: none"><input type="checkbox" checked> eat<ul><li style="list-style: none"><input type="checkbox"> eat</li></ul></li></ul></blockquote><ul><li><strong>版本控制语法</strong><br>与编写代码的语法类似，只不过代码的语言换成<code>diff</code>,同时以<code>+</code>开头表示新增，以<code>-</code>开头表示删除<br>似乎在博客上无法解析这个语法<br><code>`</code>diff</li></ul><ul><li>我是新增加的内容</li></ul><ul><li>我是减少的内容<br><code>`</code></li></ul>]]></content>
      
      <categories>
          
          <category> 有意思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同步、异步、阻塞、非阻塞</title>
      <link href="/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
      <url>/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
      <content type="html"><![CDATA[<p>“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。 </p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>　　同步与异步同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。<br>而异步则是相反，<em>调用</em>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。典型的异步编程模型比如Node.js<br>举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。  </p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>　　阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.<br>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。<br>还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Object 与 Objects</title>
      <link href="/Objects%E4%B8%8EObject/"/>
      <url>/Objects%E4%B8%8EObject/</url>
      <content type="html"><![CDATA[<p>看书看到Object,后来又看到了Objects,这两个非常相似，为了更加清晰的找出两者的不同，特地收录进来。</p><h2 id="Object（原始Object）"><a href="#Object（原始Object）" class="headerlink" title="Object（原始Object）"></a>Object（原始Object）</h2><p><strong>java.lang.Object</strong><br>所有的class都继承自Object类，这是所有类的父类。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>clone</li><li>equals</li><li>getClass</li><li>hashCode</li><li>toString  </li></ul><p>处理线程时才会被调用：  </p><ul><li>notify</li><li>notifyAll</li><li>wait</li><li>wait(long timeout)</li><li>wait(long timeout,int nanos)  </li></ul><p><strong>1. public final Class&lt;?&gt; getClass()</strong><br>final方法，不允许子类重写<br>返回<em>当前运行时</em>对象的Class对象（当前程序运行时怎么理解？？？）  </p><p><strong>2. public int hashCode()</strong><br>返回这个对象的哈希值（主要使用在hash table 、 HashMap）<br><strong>三大定律：</strong>   </p><blockquote></blockquote><ol><li>在java程序执行的过程中，一个对象在没有改变的情况下，无论被调用多少次，哈希码都是不变的（返回相同的整数值）  </li><li>如果用equals方法比较两个对象相等，则这两个对象一定返回相同的哈希值  </li><li>如果用equals方法比较两个对象不相等，两个对象的哈希值可能相等。但是不同的哈希值可以提高哈希表的性能。<br>由于所有类都是继承自Object类的，因此每一个对象都有hashcode方法。通常情况下，不同的对象产生的哈希值不同，因为默认的哈希值是通过hashcode方法导出的对象的存储地址。（那为什么还要重写hashcode方法？，直接用默认的不就可以了？？？？）  </li></ol><p><strong>3.public boolean equals(Object obj)</strong><br>比较两个对象是否相等，Object中默认的equals方法相当于比较两个对象的内存地址是否相等。  </p><blockquote></blockquote><ul><li>reflexive，自反性。任何<em>非空</em>引用值x，对于x.equals(x)必须返回true  </li><li>symmetric，对称性。任何<em>非空</em>引用值x和y，如果x.equals(y)为true，那么y.equals(x)也必须为true  </li><li>transitive，传递性。任何<em>非空</em>引用值x、y和z，如果x.equals(y)为true并且y.equals(z)为true，那么x.equals(z)也必定为true  </li><li>consistent，一致性。任何<em>非空</em>引用值x和y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改  </li><li>对于任何<em>非空</em>引用值 x，x.equals(null) 都应返回 false  </li></ul><p>如果重写equals方法，通常需要重写hashcode方法。<br>默认的equals方法中，如果两个非空引用值引用同一个对象，则equals方法返回true。  </p><p>较完美重写equals方法（Object类中，与Objects类不同）：  </p><blockquote><p>假定传入参数为otherObject。  </p><ol><li>首先检查this与otherObject是否引用同一个对象。<br>if (this == otherObject) return true;<br>这是一个优化，也是一种常用的形式。因为计算这个等式的代价要比一个一个比较类中的域付出的代价小得多。  </li><li>检查otherObject是否为null，是则为false，这个检查很有必要。<br>if (otherObject == null) return false;  </li><li>比较this和otherObject是否属于同一个类。如果equals语义在每个子类中有所改变（由子类决定相等的概念），就使用getClass检测。<br>if (getClass != otherObject.getClass()) return false;<br>如果所有子类都拥有统一的语义（由超类决定相等的概念），就使用<a href="http://www.cnblogs.com/rodney/archive/2005/08/18/instanceof.html" target="_blank" rel="noopener">instanceof（）</a>检测。<br>if (!(otherObject instanceof ClassName）) return false;  </li><li>将otherObject转化为相应的类类型变量。<br>ClassName other = (ClassName) otherObject  </li><li>使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，则返回true，否则返回false。<br>return field1 == other.field1 &amp;&amp; field2.equals(other.field2) &amp;&amp; …<br>如果在子类中重新定义equals，就要在其中包含调用super.equals(other)  </li></ol></blockquote><p><strong>4. protected Object clone() throws CloneNotSupportedException</strong><br>创建并返当前对象的一份拷贝<br><em>通常情况下</em> <code>x.clone() != x</code> 会是真； <code>clone().getClass() == x.getClass()</code> 也会是真；同时 <code>x.clone().equals(x)</code> 也会是真。<br>Object本身没有实现Cloneable接口，所以如果没有直接重写的话会产生错误（CloneNotSupportedException）。<br>如果要使用Clone方法需要继承Cloneable接口，同时重写Clone方法，通常是super.clone()<br>例：</p><pre><code> @Overridepublic Object clone() throws  CloneNotSupportedException{Father father = (Father)super.clone();return father;}</code></pre><p>同时还要注意深复制和浅复制的问题。<br>还没有解决的问题，关于数组的方法  <em>对于数组而言，clone方法都是浅复制方法。</em></p><p><strong>5.public String toString()</strong><br>返回表时对象值得字符串</p><pre><code>public String toString() {return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());}</code></pre><p>例如原生toString方法：</p><pre><code>Clone.Father@677327b6  </code></pre><p>官方推荐所有的Object子类都重写toString方法。  </p><h2 id="Objects（继承自Object）"><a href="#Objects（继承自Object）" class="headerlink" title="Objects（继承自Object）"></a>Objects（继承自Object）</h2><p><strong>java.util.Objects</strong>  </p><ol><li>全部是静态方法  </li><li>在计算hash code，返回字符串，比较两个object时，包括了null 的安全方法（不用验证null）</li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA强制类型转换</title>
      <link href="/Java%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/Java%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>有关Java中的强制类型转换问题</p><h2 id="转换分类"><a href="#转换分类" class="headerlink" title="转换分类"></a>转换分类</h2><ol><li>基本数据类型强制转换<br>从存储范围大的类型到存储范围小的类型</li><li>引用数据类型强制转换<br>结论：在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。  </li></ol><p>成功的例子:  </p><blockquote><p><code>Father father = new Son();</code><br><code>Son son = (Son) father;</code>  </p></blockquote><p>失败的例子:  </p><blockquote><p><code>Father father = new Father();</code><br> <code>Son son = (Son) father;</code>   </p></blockquote><p>编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Clone方法——深复制与浅复制</title>
      <link href="/clone%E6%96%B9%E6%B3%95%E2%80%94%E6%B7%B1%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6/"/>
      <url>/clone%E6%96%B9%E6%B3%95%E2%80%94%E6%B7%B1%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>在学习clone方法的时候产生的一点小思考<br><a id="more"></a><br>如果使用clone方法必须实现Cloneable方法。<br>在复制过程中存在深复制与浅复制。浅复制仅仅复制基本类型，对于引用类型则没有完全复制，仅仅是引用而已。深复制则不同，全部复制。</p><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><pre><code>public class CloneTest {    public static void main(String[] args) throws CloneNotSupportedException {    Father father = new Father(50,&quot;Father&quot;);    Father father1 = (Father) father.clone();    father1.setAge(10);    father1.setName(&quot;Father1&quot;);    System.out.println(father + &quot; &quot; +father.getAge() + &quot; &quot; + father.getName());    System.out.println(father1 + &quot; &quot; +father1.getAge() + &quot; &quot; + father1.getName());  }}</code></pre><p>输出结果是  </p><pre><code>Clone.Father@677327b6 50 FatherClone.Father@14ae5a5 10 Father1</code></pre><p>事实证明，使用clone进行的拷贝对于基本数据类型是进行新建空间复制过去的。</p><pre><code>public class Father implements Cloneable {    private String name;    private int age;    private ID id;        public Father(ID id,String name,int age){        this.id = id;        this.name = name;        this.age = age;    }        public void setId(ID id){        this.id = id;    }        public ID getId() {        return id;    }    @Override        public Object clone() throws  CloneNotSupportedException{        Father father = (Father)super.clone();        return father;        }}public class ID {    private int ID;        public void setID(int ID){        this.ID = ID;    }        public int getID(){        return ID;    }}public class CloneTest {    public static void main(String[] args) throws CloneNotSupportedException {        ID id = new ID();        id.setID(1);        Father father = new Father(id,&quot;Father&quot;,40);        Father father1 = (Father)father.clone();        System.out.println(father.getId().getID());        System.out.println(father1.getId().getID());        id.setID(2);        System.out.println(father.getId().getID());        System.out.println(father1.getId().getID());    }}</code></pre><p>输出结果为：</p><pre><code>1122</code></pre><p>可见修改一个ID，两个对象都改变了ID，所以可以发现，两个ID使用的都是同一块地址，所以修改ID才会造成两个对象同时改变地址。</p><h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>深复制的实现是通过将浅复制实现cloneable  </p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深入思考 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>Tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>Timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
